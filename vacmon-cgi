#!/usr/bin/python
#
#  viabmon-cgi - Vacmon CGI script
#
#  Andrew McNab, University of Manchester.
#  Copyright (c) 2015-6. All rights reserved.
#
#  Redistribution and use in source and binary forms, with or
#  without modification, are permitted provided that the following
#  conditions are met:
#
#    o Redistributions of source code must retain the above
#      copyright notice, this list of conditions and the following
#      disclaimer. 
#    o Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials
#      provided with the distribution. 
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
#  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
#  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
#  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
#  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
#  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
#  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.
#
#  Contacts: Andrew.McNab@cern.ch  http://www.gridpp.ac.uk/vacproject/
#

import os
import cgi
import sys
import time
import json
import pygal
import string
import pprint
import elasticsearch

class VacMonStackedLine(pygal.StackedLine):

  def __init__(self, timeStart, timeEnd, timeBuckets):
        pygal.StackedLine.__init__(self, include_x_axis=True, stroke_style={'width': 2}, legend_at_bottom=True, show_x_guides=True, style=pygal.style.LightColorizedStyle, x_label_rotation=30)

        self.x_labels = [ timeStart + (i + 0.5) * ((timeEnd - timeStart) / timeBuckets)  for i in range(0, timeBuckets) ]

  def _points(self, x_pos):
        # Unfilled series to be overlayed rather than stacked
        """
        Convert given data values into drawable points (x, y)
        and interpolated points if interpolate option is specified
        """
        for series_group in (self.series, self.secondary_series):
            accumulation = [0] * self._len
            for serie in series_group[::-1 if self.stack_from_top else 1]:
              if serie.fill == False: # <--- this is the significant change
                serie.points = [ (x_pos[i], v) for i, v in enumerate(serie.values) ]
                if serie.points and self.interpolate:
                    serie.interpolated = self._interpolate(x_pos, serie.values)
                else:
                    serie.interpolated = []                
              else:
                accumulation = list(map(sum, zip(accumulation, serie.values)))
                serie.points = [
                    (x_pos[i], v)
                    for i, v in enumerate(accumulation)]
                if serie.points and self.interpolate:
                    serie.interpolated = self._interpolate(x_pos, accumulation)
                else:
                    serie.interpolated = []

  def htmlPrint(self):
        print '<figure>'
        print self.render()
        print '</figure>'

def htmlHeader(title):
  print 'Status: 200 OK'
  print 'Content-Type: text/html'
  print
  print '<html><head><title>' + title + '</title>'
  print open('/var/www/vacmon/header.html', 'r').read()

def htmlFooter():
  print open('/var/www/vacmon/footer.html', 'r').read()
  print '</html>'

def oneFactory(timeStart, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName, spaceName, factoryName):

  htmlHeader('VacMon ' + factoryName)

  print ('<div class="breadcrumbs"><a href="/' + sizeTimeRangeVO + '/">VacMon</a> ' +
         '/ <a href="/' + sizeTimeRangeVO + '/' + siteName + '/">' + siteName + '</a> ' +
         '/ <a href="/' + sizeTimeRangeVO + '/' + siteName + '/' + spaceName + '/">' + spaceName + '</a> ' +
         '/ ' + factoryName.split('.')[0] + '</div>')
                             
  print '<h1>Factory ' + factoryName + '</h1>'

  try:
    es = elasticsearch.Elasticsearch()
  
    factoriesSearch =  """{
            "query":
              {
                "bool":
                {
                  "filter":
                    [
                       { "range": { "received_time": { "from": %ld, "to": %ld } } },
                       { "term":  { "site":    "%s" } },
                       { "term":  { "space":   "%s" } },
                       { "term":  { "factory": "%s" } }
                    ]
                }
              },
            "aggs" : 
              {
                "factory_load_histogram": 
                  {
                    "date_histogram": 
                      { 
                        "field"          : "received_time",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 0,
                        "offset"         : %ld,
                        "extended_bounds":
                          {
                            "min": %ld,
                            "max": %ld
                          }
                      },
                    "aggs":
                      {
                        "time_average":         { "avg": { "field": "received_time"            } },
                        "load_average":         { "avg": { "field": "load_average"         } },
                        "max_processors":       { "avg": { "field": "max_processors"       } },
                        "running_processors":   { "avg": { "field": "running_processors"   } },
                        "max_machines":         { "avg": { "field": "max_machines"         } },
                        "running_machines":     { "avg": { "field": "running_machines"     } },
                        "max_hs06":             { "avg": { "field": "max_hs06"             } },
                        "running_hs06":         { "avg": { "field": "running_hs06"         } },
                        "root_disk_avail_kb":   { "avg": { "field": "root_disk_avail_kb"   } },
                        "daemon_disk_avail_kb": { "avg": { "field": "daemon_disk_avail_kb" } },
                        "mem_total_kb":         { "avg": { "field": "mem_total_kb"         } },
                        "mem_used_kb":          { "avg": { "field": "mem_used_kb"          } },
                        "swap_free_kb":         { "avg": { "field": "swap_free_kb"         } },
                        "swap_used_kb":         { "avg": { "field": "swap_used_kb"         } }
                      }
                  }
              }                         
           }""" % (timeStart, timeEnd, siteName, spaceName, factoryName, (timeEnd - timeStart) / timeBuckets, timeStart * 1000, timeStart * 1000, timeEnd * 1000)

    print '<pre>'
    pprint.pprint(json.loads(factoriesSearch))

    fs = es.search(index = 'vacmon', doc_type = 'factories', size = 0, body = factoriesSearch)

    pprint.pprint(fs)
    print '</pre>'
    
    machinetypesSearch =  """{
            "query":
              {
                "bool":
                {
                  "filter":
                    [
                       { "range": { "received_time": { "from": %ld, "to": %ld } } },
                       { "term":  { "site":    "%s" } },
                       { "term":  { "space":   "%s" } },
                       { "term":  { "factory": "%s" } }
                    ]
                }
              },
            "aggs" : 
              {
                "machinetype_histogram": 
                  {
                    "date_histogram": 
                      { 
                        "field"          : "received_time",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 0,
                        "offset"         : %ld,
                        "extended_bounds":
                          {
                            "min": %ld,
                            "max": %ld
                          }
                      },
                    "aggs":
                      {
                        "machinetype":
                          {
                            "terms": { "field": "machinetype", "size" : 99999 },
                            "aggs":  { "running_processors": { "avg": { "field": "running_processors" } },
                                       "running_machines":   { "avg": { "field": "running_machines"   } },
                                       "running_hs06":       { "avg": { "field": "running_hs06"       } }
                                     }

                          },                      
                        "time_average": { "avg": { "field": "received_time" } }
                      }
                  }
              }                         
           }""" % (timeStart, timeEnd, siteName, spaceName, factoryName, (timeEnd - timeStart) / timeBuckets, timeStart * 1000, timeStart * 1000, timeEnd * 1000)

    print '<pre>'
#    pprint.pprint(json.loads(machinetypesSearch))

#    ms = es.search(index = 'vacmon', doc_type = 'machinetypes', size = 0, body = machinetypesSearch)

#    pprint.pprint(ms)
    print '</pre>'
    
    loadAvgValues         = []
    maxProcValues         = []
    runningProcValues     = []
    maxMachinesValues     = []
    runningMachinesValues = []
    maxHS06Values         = []
    runningHS06Values     = []
    rootDiskValues        = []
    daemonDiskValues      = []
    memUsedValues         = []
    memFreeValues         = []
    swapUsedValues        = []
    swapFreeValues        = []

    for i in fs['aggregations']['factory_load_histogram']['buckets']:
       if i['key'] >= timeStart * 1000 and i['key'] < timeEnd * 1000:
         loadAvgValues.append(i['load_average']['value'] if i['load_average']['value'] else 0)
         maxProcValues.append(i['max_processors']['value'])
         runningProcValues.append(i['running_processors']['value'])

         maxMachinesValues.append(i['max_machines']['value'])
         runningMachinesValues.append(i['running_machines']['value'])

         maxHS06Values.append(i['max_hs06']['value'])
         runningHS06Values.append(i['running_hs06']['value'])

         rootDiskValues.append(i['root_disk_avail_kb']['value'] / 1000)
         daemonDiskValues.append(i['daemon_disk_avail_kb']['value'] / 1000)

         memUsedValues.append(i['mem_used_kb']['value'] / 1024)
         memFreeValues.append((i['mem_total_kb']['value'] - i['mem_used_kb']['value']) / 1024)
         
         swapUsedValues.append(i['swap_used_kb']['value'] / 1024)
         swapFreeValues.append(i['swap_free_kb']['value'] / 1024)

    # Load/processors on this factory

    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'CPU load & processors on factory ' + factoryName
    chart.add('Load average',     loadAvgValues, fill=True, show_dots=False)
    chart.add('Running processors', runningProcValues, fill=False, show_dots=False)
    chart.add('Max processors',     maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()

    # Machines on this factory

    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'Machines on factory ' + factoryName
    chart.add('Running machines', runningMachinesValues, fill=True, show_dots=False)
    chart.add('Max machines',     maxMachinesValues, fill=False, show_dots=False)
    chart.htmlPrint()

    # HS06 on this factory

    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'HS06 on factory ' + factoryName
    chart.add('Running HS06', runningHS06Values, fill=True, show_dots=False)
    chart.add('Max HS06',     maxHS06Values, fill=False, show_dots=False)
    chart.htmlPrint()

    # Available disk on this factory

    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'Available disk on factory ' + factoryName
    chart.add('Root disk free (MB)', rootDiskValues, fill=True, show_dots=False)
    chart.add('Daemon disk free (MB)', daemonDiskValues, fill=True, show_dots=False)
    chart.htmlPrint()

    # Memory/swap on this factory

    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'Memory/swap on factory ' + factoryName
    chart.add('Mem used (MiB)', memUsedValues, fill=True, show_dots=False)
    chart.add('Mem free (MiB)', memFreeValues, fill=True, show_dots=False)
    chart.add('Swap used (MiB)', swapUsedValues, fill=True, show_dots=False)
    chart.add('Swap free (MiB)', swapFreeValues, fill=True, show_dots=False)
    chart.htmlPrint()

  except Exception as e:
    print str(e)
    
  htmlFooter()
  
def oneSpace(timeStart, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName, spaceName):

  htmlHeader('VacMon ' + spaceName)

  print ('<div class="breadcrumbs"><a href="/' + sizeTimeRangeVO + '/">VacMon</a> ' +
         '/ <a href="/' + sizeTimeRangeVO + '/' + siteName + '/">' + siteName + '</a> ' +
         '/ ' + spaceName + '</div>')
                             
  print '<h1>Space ' + spaceName + '</h1>'

  try:
    es = elasticsearch.Elasticsearch()
  
    searchBody =  """{
            "query": 
              {
                "bool":
                 {
                   "filter":
                     [
                       { "range": { "received_time": { "from": %ld, "to": %ld } } },
                       { "term":  { "site": "%s"  } },
                       { "term":  { "space": "%s" } }
                     ]
                 }
              },
            "aggs" : 
              {
                "factory_names":
                  {
                    "terms":
                      {
                        "field": "factory",
                        "size" : 99999,
                        "order" : { "_term" : "asc" }
                      }
                  },
                "space_histogram": 
                  {
                    "date_histogram": 
                      { 
                        "field"          : "received_time",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 0,
                        "offset"         : %ld,
                        "extended_bounds": { "min": %ld, "max": %ld }
                      },
                    "aggs": 
                      {
                        "factory":
                          {
                            "terms": { "field": "factory", "size" : 99999 },
                            "aggs":  { "load_average":       { "avg": { "field" : "load_average"      } },
                                       "max_processors":     { "avg": { "field" : "max_processors"    } },
                                       "running_processors": { "avg": { "field": "running_processors" } },
                                       "max_machines":       { "avg": { "field": "max_machines"       } },
                                       "running_machines":   { "avg": { "field": "running_machines"   } },
                                       "max_hs06":           { "avg": { "field": "max_hs06"           } },
                                       "running_hs06":       { "avg": { "field": "running_hs06"       } }
                                     }
                          },
                        "load_average_space":       { "sum_bucket": { "buckets_path": "factory>load_average"       } },
                        "max_processors_space":     { "sum_bucket": { "buckets_path": "factory>max_processors"     } },
                        "running_processors_space": { "sum_bucket": { "buckets_path": "factory>running_processors" } },
                        "max_machines_space":       { "sum_bucket": { "buckets_path": "factory>max_machines"       } },
                        "running_machines_space":   { "sum_bucket": { "buckets_path": "factory>running_machines"   } },
                        "max_hs06_space":           { "sum_bucket": { "buckets_path": "factory>max_hs06"           } },
                        "running_hs06_space":       { "sum_bucket": { "buckets_path": "factory>running_hs06"       } }
                      }
                  }
              }
           }""" % (timeStart, timeEnd, siteName, spaceName, (timeEnd - timeStart) / timeBuckets, timeStart * 1000, timeStart * 1000, timeEnd * 1000)

    print '<pre>'
    pprint.pprint(json.loads(searchBody))

    t = es.search(
          index    = 'vacmon',
          doc_type = 'factories',
          size     = 0,
          body     = searchBody)

    pprint.pprint(t)
    print '</pre>'
    
    loadAvgValues     = []
    maxProcValues     = []
    maxMachinesValues = []
    maxHS06Values     = []
    
    factoryLoadAvgLists = {}
    factoryRunningProcLists = {}
    factoryRunningMachinesLists = {}
    factoryRunningHS06Lists = {}

    for j in t['aggregations']['factory_names']['buckets']:
      factoryLoadAvgLists[j['key']] = []
      factoryRunningProcLists[j['key']] = []
      factoryRunningMachinesLists[j['key']] = []
      factoryRunningHS06Lists[j['key']] = []

    for i in t['aggregations']['space_histogram']['buckets']:
       if i['key'] >= timeStart * 1000 and i['key'] < timeEnd * 1000:
         loadAvgValues.append(i['load_average_space']['value'] if i['load_average_space']['value'] else 0)

         maxProcValues.append(i['max_processors_space']['value'])
         maxMachinesValues.append(i['max_machines_space']['value'])
         maxHS06Values.append(i['max_hs06_space']['value'])

         for j in i['factory']['buckets']:
           factoryLoadAvgLists[j['key']].append(j['load_average']['value'])
           factoryRunningProcLists[j['key']].append(j['running_processors']['value'])
           factoryRunningMachinesLists[j['key']].append(j['running_machines']['value'])
           factoryRunningHS06Lists[j['key']].append(j['running_hs06']['value'])

    # CPU load per factory

    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'CPU load in space ' + spaceName

    for j in t['aggregations']['factory_names']['buckets']:
      chart.add( { 'title': j['key'].split('.')[0], 'xlink': {'href': '/%s/%s/%s/%s/' % (sizeTimeRangeVO, siteName, spaceName, j['key']) } },
                      factoryLoadAvgLists[j['key']], 
                      fill=True, 
                      show_dots=False)

    chart.add('Max processors',     maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()

    # Running processors per factory
    
    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'Processors in space ' + spaceName
    for j in t['aggregations']['factory_names']['buckets']:
      chart.add( { 'title': j['key'].split('.')[0], 'xlink': {'href': '/%s/%s/%s/%s/' % (sizeTimeRangeVO, siteName, spaceName, j['key']) } },
                      factoryRunningProcLists[j['key']], 
                      fill=True, 
                      show_dots=False )

    chart.add('Max processors', maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # Running machines per factory
    
    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'Machines in space ' + spaceName
    for j in t['aggregations']['factory_names']['buckets']:
      chart.add( { 'title': j['key'].split('.')[0], 'xlink': {'href': '/%s/%s/%s/%s/' % (sizeTimeRangeVO, siteName, spaceName, j['key']) } },
                      factoryRunningMachinesLists[j['key']], 
                      fill=True, 
                      show_dots=False )

    chart.add('Max machines', maxMachinesValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # Running HS06 per factory
    
    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'HS06 in space ' + spaceName
    for j in t['aggregations']['factory_names']['buckets']:
      chart.add( { 'title': j['key'].split('.')[0], 'xlink': {'href': '/%s/%s/%s/%s/' % (sizeTimeRangeVO, siteName, spaceName, j['key']) } },
                      factoryRunningHS06Lists[j['key']], 
                      fill=True, 
                      show_dots=False )

    chart.add('Max HS06', maxHS06Values, fill=False, show_dots=False)
    chart.htmlPrint()
    
  except Exception as e:
    print str(e)
    
  htmlFooter()
  
def oneSite(timeStart, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName):

  htmlHeader('VacMon ' + siteName)

  print ('<div class="breadcrumbs"><a href="/' + sizeTimeRangeVO + '/">VacMon</a> / ' + siteName + '</div>')
                             
  print '<h1>Site ' + siteName + '</h1>'

  try:
    es = elasticsearch.Elasticsearch()
  
    searchBody =  """{
            "query": 
              {
                "bool":
                 {
                   "filter":
                     [
                       { "range": { "received_time": { "from": %ld, "to": %ld } } },
                       { "match": { "site": "%s" } }
                     ]
                 }
              },
            "aggs" : 
              {
                "space_names":
                  {
                    "terms":
                      {
                        "field": "space",
                        "size" : 99999,
                        "order" : { "_term" : "asc" }
                      }
                  },
                "site_histogram":
                  {
                    "date_histogram": 
                      { 
                        "field"          : "received_time",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 0,
                        "offset"         : %ld,
                        "extended_bounds": { "min": %ld, "max": %ld }
                      },
                    "aggs":
                      {
                        "space":
                          {
                            "terms": { "field": "space", "size" : 99999 },
                            "aggs": { "factory": { "terms": { "field": "factory", "size" : 99999 },
                                                   "aggs":  { "max_processors":     { "avg": { "field" : "max_processors"     } },
                                                              "running_processors": { "avg": { "field" : "running_processors" } },
                                                              "max_machines":       { "avg": { "field" : "max_machines"       } },
                                                              "running_machines":   { "avg": { "field" : "running_machines"   } },
                                                              "max_hs06":           { "avg": { "field" : "max_hs06"           } },
                                                              "running_hs06":       { "avg": { "field" : "running_hs06"       } }
                                                            }
                                                 },
                                      "max_processors_space":     { "sum_bucket": { "buckets_path": "factory>max_processors"     } },
                                      "running_processors_space": { "sum_bucket": { "buckets_path": "factory>running_processors" } },
                                      "max_machines_space":       { "sum_bucket": { "buckets_path": "factory>max_machines"       } },
                                      "running_machines_space":   { "sum_bucket": { "buckets_path": "factory>running_machines"   } },
                                      "max_hs06_space":           { "sum_bucket": { "buckets_path": "factory>max_hs06"           } },
                                      "running_hs06_space":       { "sum_bucket": { "buckets_path": "factory>running_hs06"       } }
                                    }
                          },
                        "max_processors_site":     { "sum_bucket":  { "buckets_path": "space>max_processors_space"     } },
                        "running_processors_site": { "sum_bucket":  { "buckets_path": "space>running_processors_space" } },
                        "max_machines_site":       { "sum_bucket":  { "buckets_path": "space>max_machines_space"       } },
                        "running_machines_site":   { "sum_bucket":  { "buckets_path": "space>running_machines_space"   } },
                        "max_hs06_site":           { "sum_bucket":  { "buckets_path": "space>max_hs06_space"           } },
                        "running_hs06_site":       { "sum_bucket":  { "buckets_path": "space>running_hs06_space"       } }
                      }
                  }
              }
           }""" % (timeStart, timeEnd, siteName, (timeEnd - timeStart) / timeBuckets, timeStart * 1000, timeStart * 1000, timeEnd * 1000)

    print '<pre>'
#    pprint.pprint(json.loads(searchBody))

    t = es.search(
          index    = 'vacmon',
          doc_type = 'factories',
          size     = 0,
          body     = searchBody)

#    pprint.pprint(t)
    print '</pre>'
    
    maxProcValues         = []
    maxMachinesValues     = []
    maxHS06Values         = []

    spaceRunningProcLists = {}
    spaceRunningMachinesLists = {}
    spaceRunningHS06Lists = {}

    for j in t['aggregations']['space_names']['buckets']:
      spaceRunningProcLists[j['key']] = []
      spaceRunningMachinesLists[j['key']] = []
      spaceRunningHS06Lists[j['key']] = []

    for i in t['aggregations']['site_histogram']['buckets']:
       if i['key'] >= timeStart * 1000 and i['key'] < timeEnd * 1000:
         maxProcValues.append(i['max_processors_site']['value'])
         maxMachinesValues.append(i['max_machines_site']['value'])
         maxHS06Values.append(i['max_hs06_site']['value'])

         for j in i['space']['buckets']:
           spaceRunningProcLists[j['key']].append(j['running_processors_space']['value'])
           spaceRunningMachinesLists[j['key']].append(j['running_machines_space']['value'])
           spaceRunningHS06Lists[j['key']].append(j['running_hs06_space']['value'])

    # Processors running at this site

    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'Running processors at site ' + siteName

    for j in t['aggregations']['space_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': {'href': '/%s/%s/%s/' % (sizeTimeRangeVO, siteName, j['key']) } },
                      spaceRunningProcLists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max processors',  maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # Machines running at this site

    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'Running machines at site ' + siteName

    for j in t['aggregations']['space_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': {'href': '/%s/%s/%s/' % (sizeTimeRangeVO, siteName, j['key']) } },
                      spaceRunningMachinesLists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max machines',  maxMachinesValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # HS06 running at this site

    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'Running HS06 at site ' + siteName

    for j in t['aggregations']['space_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': {'href': '/%s/%s/%s/' % (sizeTimeRangeVO, siteName, j['key']) } },
                      spaceRunningHS06Lists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max HS06',  maxHS06Values, fill=False, show_dots=False)
    chart.htmlPrint()
    
  except Exception as e:
    print str(e)
    
  htmlFooter()
  
def allSites(timeStart, timeEnd, timeBuckets, voName, sizeTimeRangeVO):

  htmlHeader('VacMon ' + siteName)

  print ('<div class="breadcrumbs">VacMon</div>')
                             
  print '<h1>All sites</h1>'

  try:
    es = elasticsearch.Elasticsearch()
  
    searchBody =  """{
            "query": 
              {
                "bool":
                 {
                   "filter":
                     [
                       { "range": { "received_time": { "from": %ld, "to":   %ld } } }
                     ]
                 }
              },
            "aggs" : 
              {
                "site_names":
                  {
                    "terms": { "field": "site", "size" : 99999, "order" : { "_term" : "asc" } }
                  },
                "all_histogram":
                  {
                    "date_histogram": 
                      { 
                        "field"          : "received_time",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 0,
                        "offset"         : %ld,
                        "extended_bounds": { "min": %ld, "max": %ld }
                      },
                    "aggs":
                      {
                        "site":
                          {
                            "terms": { "field": "site", "size" : 99999 },
                            "aggs":
                              {
                                "space":
                                  {
                                    "terms": { "field": "space", "size" : 99999 },
                                    "aggs":  
                                      { "factory":
                                          {
                                            "terms": { "field": "factory", "size" : 99999 },
                                            "aggs":
                                              {                                                            
                                                "max_processors":     { "avg": { "field" : "max_processors"     } },
                                                "running_processors": { "avg": { "field" : "running_processors" } },
                                                "max_machines":       { "avg": { "field" : "max_machines"       } },
                                                "running_machines":   { "avg": { "field" : "running_machines"   } },
                                                "max_hs06":           { "avg": { "field" : "max_hs06"           } },
                                                "running_hs06":       { "avg": { "field" : "running_hs06"       } }
                                              }
                                          },
                                        "max_processors_space":     { "sum_bucket": { "buckets_path": "factory>max_processors"     } },
                                        "running_processors_space": { "sum_bucket": { "buckets_path": "factory>running_processors" } },
                                        "max_machines_space":       { "sum_bucket": { "buckets_path": "factory>max_machines"       } },
                                        "running_machines_space":   { "sum_bucket": { "buckets_path": "factory>running_machines"   } },
                                        "max_hs06_space":           { "sum_bucket": { "buckets_path": "factory>max_hs06"           } },
                                        "running_hs06_space":       { "sum_bucket": { "buckets_path": "factory>running_hs06"       } }
                                      }
                                  },
                                "max_processors_site":     { "sum_bucket": { "buckets_path": "space>max_processors_space"     } },
                                "running_processors_site": { "sum_bucket": { "buckets_path": "space>running_processors_space" } },
                                "max_machines_site":       { "sum_bucket": { "buckets_path": "space>max_machines_space"       } },
                                "running_machines_site":   { "sum_bucket": { "buckets_path": "space>running_machines_space"   } },
                                "max_hs06_site":           { "sum_bucket": { "buckets_path": "space>max_hs06_space"           } },
                                "running_hs06_site":       { "sum_bucket": { "buckets_path": "space>running_hs06_space"       } }
                              }
                          },
                        "max_processors_all":     { "sum_bucket": { "buckets_path": "site>max_processors_site"     } },
                        "running_processors_all": { "sum_bucket": { "buckets_path": "site>running_processors_site" } },
                        "max_machines_all":       { "sum_bucket": { "buckets_path": "site>max_machines_site"       } },
                        "running_machines_all":   { "sum_bucket": { "buckets_path": "site>running_machines_site"   } },
                        "max_hs06_all":           { "sum_bucket": { "buckets_path": "site>max_hs06_site"           } },
                        "running_hs06_all":       { "sum_bucket": { "buckets_path": "site>running_hs06_site"       } }
                      }
                  }
              }
           }""" % (timeStart, timeEnd, (timeEnd - timeStart) / timeBuckets, timeStart * 1000, timeStart * 1000, timeEnd * 1000)

    print '<pre>'
#    pprint.pprint(json.loads(searchBody))

    t = es.search(
          index    = 'vacmon',
          doc_type = 'factories',
          size     = 0,
          body     = searchBody)

#    pprint.pprint(t)
    print '</pre>'
    
    maxProcValues         = []
    maxMachinesValues     = []
    maxHS06Values         = []

    siteRunningProcLists = {}
    siteRunningMachinesLists = {}
    siteRunningHS06Lists = {}

    for j in t['aggregations']['site_names']['buckets']:
      siteRunningProcLists[j['key']] = []
      siteRunningMachinesLists[j['key']] = []
      siteRunningHS06Lists[j['key']] = []

    for i in t['aggregations']['all_histogram']['buckets']:
       if i['key'] >= timeStart * 1000 and i['key'] < timeEnd * 1000:
         maxProcValues.append(i['max_processors_all']['value'])
         maxMachinesValues.append(i['max_machines_all']['value'])
         maxHS06Values.append(i['max_hs06_all']['value'])

         for j in i['site']['buckets']:
           siteRunningProcLists[j['key']].append(j['running_processors_site']['value'])
           siteRunningMachinesLists[j['key']].append(j['running_machines_site']['value'])
           siteRunningHS06Lists[j['key']].append(j['running_hs06_site']['value'])

    # Processors running at all sites

    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'Running processors'

    for j in t['aggregations']['site_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': { 'href':'/%s/%s/' % (sizeTimeRangeVO, j['key']) } },
                      siteRunningProcLists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max processors',  maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # Machines running at all sites

    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'Running machines'

    for j in t['aggregations']['site_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': { 'href': '/%s/%s/' % (sizeTimeRangeVO, j['key']) } },
                      siteRunningMachinesLists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max machines',  maxMachinesValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # HS06 running at all sites

    chart = VacMonStackedLine(timeStart, timeEnd, timeBuckets)
    chart.title = 'Running HS06'

    for j in t['aggregations']['site_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': { 'href': '/%s/%s/' % (sizeTimeRangeVO, j['key']) } },
                      siteRunningHS06Lists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max HS06',  maxHS06Values, fill=False, show_dots=False)
    chart.htmlPrint()
    
  except Exception as e:
    print str(e)
    
  htmlFooter()
  
#
# PROGRAM MAIN
#

vacmonVersion = open('/var/www/vacmon/VERSION','r').readline().split('=',1)[1].strip()
requestURI    = os.environ['REQUEST_URI']

if '..' in requestURI or string.translate(requestURI, None, '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-./:') != '':
  # Redirect to main page if unacceptable characters in URI
  print 'Status: 302 Found 0'
  print 'Location: http://vacmon.gridpp.ac.uk/260:15180/'
  print
  sys.exit(0)

sizeTimeRangeVO, siteName, spaceName, factoryName = (requestURI + '////').split('/')[1:5]

# Static pages: main page and documentation

if not sizeTimeRangeVO:
  htmlHeader('VacMon')

  try:
    print open('/var/www/vacmon/index.html', 'r').read()
  except:
    pass  

  htmlFooter()
  sys.exit(0)

# Parse timeRange
splitSizeTimeRangeVO = sizeTimeRangeVO.split(':')

if len(splitSizeTimeRangeVO) < 2:
  print 'Status: 302 Found 1'
  print 'Location: http://vacmon.gridpp.ac.uk/260:15180/'
  print
  sys.exit(0)

try:
  imageSize = int(splitSizeTimeRangeVO[0], 16)
except:
  print 'Status: 302 Found 2'
  print 'Location: http://vacmon.gridpp.ac.uk/260:15180/'
  print
  sys.exit(0)

timeRange = splitSizeTimeRangeVO[1]

if len(splitSizeTimeRangeVO) > 2:
  voName = splitSizeTimeRangeVO[2]
else:
  voName = None

if '-' in timeRange:
  try:
    timeStart = int(timeRange.split('-')[0], 16)
    timeEnd   = int(timeRange.split('-')[1], 16)
  except:
    print 'Status: 302 Found 3'
    print 'Location: http://vacmon.gridpp.ac.uk/260:15180/'
    print
    sys.exit(0)
    
else:
  try:
    timeEnd   = int(time.time())
    timeStart = timeEnd - int(timeRange, 16)
  except:
    print 'Status: 302 Found 4'
    print 'Location: http://vacmon.gridpp.ac.uk/260:15180/'
    print
    sys.exit(0)

# Pages with graphs

if siteName and spaceName and factoryName:
  oneFactory(timeStart, timeEnd, 20, voName, sizeTimeRangeVO, siteName, spaceName, factoryName)

elif siteName and spaceName:
  oneSpace(timeStart, timeEnd, 20, voName, sizeTimeRangeVO, siteName, spaceName)

elif siteName:
  oneSite(timeStart, timeEnd, 20, voName, sizeTimeRangeVO, siteName)

else:
  allSites(timeStart, timeEnd, 20, voName, sizeTimeRangeVO)

sys.exit(0)
