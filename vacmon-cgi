#!/usr/bin/python
#
#  viabmon-cgi - Vacmon CGI script
#
#  Andrew McNab, University of Manchester.
#  Copyright (c) 2015-8. All rights reserved.
#
#  Redistribution and use in source and binary forms, with or
#  without modification, are permitted provided that the following
#  conditions are met:
#
#    o Redistributions of source code must retain the above
#      copyright notice, this list of conditions and the following
#      disclaimer. 
#    o Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials
#      provided with the distribution. 
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
#  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
#  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
#  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
#  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
#  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
#  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.
#
#  Contacts: Andrew.McNab@cern.ch  http://www.gridpp.ac.uk/vacproject/
#

# First two modules installed with:
#
# pip install pygal
# pip install elasticsearch
#
import pygal
import elasticsearch

import os
import cgi
import sys
import time
import json
import string
import pprint

import vacmon

esDebug   = False
esTimeout = 60

# On the all sites page, we ignore these "sites" which are due to initial testing
sitesIgnoreList = [ 'gridpp.ac.uk', 'lhcb.cern.ch', 'tier2.hep.manchester.ac.uk' ]

class VacMonStackedLine(pygal.StackedLine):

  def __init__(self, imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=3):
        self.imageSize = imageSize
        pygal.StackedLine.__init__(self, include_x_axis=True, stroke_style={'width': 2}, legend_at_bottom=True, show_x_guides=True, style=pygal.style.LightColorizedStyle, x_label_rotation=30, width=720, height=720, legend_at_bottom_columns=legend_at_bottom_columns)
        self.x_labels = [ time.strftime('%b-%d %H:%M', time.gmtime(timeEnd - timeSpan + (i + 0.5) * (timeSpan / timeBuckets))) for i in range(0, timeBuckets) ]

  def _points(self, x_pos):
        # Unfilled series to be overlayed rather than stacked
        """
        Convert given data values into drawable points (x, y)
        and interpolated points if interpolate option is specified
        """
        for series_group in (self.series, self.secondary_series):
            accumulation = [0] * self._len
            for serie in series_group[::-1 if self.stack_from_top else 1]:
              if serie.fill == False: # <--- this is the significant change
                serie.points = [ (x_pos[i], v) for i, v in enumerate(serie.values) ]
                if serie.points and self.interpolate:
                    serie.interpolated = self._interpolate(x_pos, serie.values)
                else:
                    serie.interpolated = []                
              else:
                accumulation = list(map(sum, zip(accumulation, serie.values)))
                serie.points = [
                    (x_pos[i], v)
                    for i, v in enumerate(accumulation)]
                if serie.points and self.interpolate:
                    serie.interpolated = self._interpolate(x_pos, accumulation)
                else:
                    serie.interpolated = []

  def htmlPrint(self):
        print '<a href="' + self.render_data_uri() + '"><figure style="width:%dpx; display: inline-block">' % self.imageSize
        print self.render()
        print '</figure></a> '

def htmlHeader(title, selector=True):
  print 'Status: 200 OK'
  print 'Content-Type: text/html'
  print
  print '<html><head><title>' + title + '</title>'

  if selector:
    print """<script language="JavaScript" src="/CalendarPopup.js"></script>
<script language="JavaScript">var calFrom = new CalendarPopup("selectordiv");
calFrom.setReturnFunction("setMultipleValuesFrom");
function setMultipleValuesFrom(y,m,d) {
        for (var i=0; i<document.forms[0].dateFrom_year.options.length; i++)
         { if (document.forms[0].dateFrom_year.options[i].value==y) { document.forms[0].dateFrom_year.selectedIndex=i; } }
        for (var i=0; i<document.forms[0].dateFrom_month.options.length; i++)
         { if (document.forms[0].dateFrom_month.options[i].value==m) { document.forms[0].dateFrom_month.selectedIndex=i; } }
        for (var i=0; i<document.forms[0].dateFrom_date.options.length; i++)
         { if (document.forms[0].dateFrom_date.options[i].value==d) { document.forms[0].dateFrom_date.selectedIndex=i; } }
        }
var calTo = new CalendarPopup("selectordiv");
calTo.setReturnFunction("setMultipleValuesTo");
function setMultipleValuesTo(y,m,d) {
        for (var i=0; i<document.forms[0].dateTo_year.options.length; i++)
         { if (document.forms[0].dateTo_year.options[i].value==y) { document.forms[0].dateTo_year.selectedIndex=i; } }
        for (var i=0; i<document.forms[0].dateTo_month.options.length; i++)
         { if (document.forms[0].dateTo_month.options[i].value==m) { document.forms[0].dateTo_month.selectedIndex=i; } }
        for (var i=0; i<document.forms[0].dateTo_date.options.length; i++)
         { if (document.forms[0].dateTo_date.options[i].value==d) { document.forms[0].dateTo_date.selectedIndex=i; } }
        }
function getDateString(y_obj,m_obj,d_obj) {
        var y = y_obj.options[y_obj.selectedIndex].value;
        var m = m_obj.options[m_obj.selectedIndex].value;
        var d = d_obj.options[d_obj.selectedIndex].value;
        if (y=="" || m=="") { return null; }
        if (d=="") { d=1; }
        return str= y+'-'+m+'-'+d;
        }
function timeButtonClick(imageSize, voName, uriTail) {
        var timeStart = Date.UTC(document.forms[0].dateFrom_year.value,
                                 document.forms[0].dateFrom_month.value - 1,
                                 document.forms[0].dateFrom_date.value,
                                 document.forms[0].dateFrom_hour.value,
                                 document.forms[0].dateFrom_minute.value, 0, 0)/1000;
        var timeEnd   = Date.UTC(document.forms[0].dateTo_year.value,
                                 document.forms[0].dateTo_month.value - 1,
                                 document.forms[0].dateTo_date.value,
                                 document.forms[0].dateTo_hour.value,
                                 document.forms[0].dateTo_minute.value, 0, 0)/1000;
        var timeSpan = timeEnd - timeStart;
        return '/' + imageSize.toString(16) + ':' +
                     timeSpan.toString(16) + ':' +
                     timeEnd.toString(16) + ':' +
                     voName + uriTail;
        }

document.write(getCalendarStyles());
</script>"""
  
  print open('/var/www/vacmon/header.html', 'r').read()

def htmlFooter():
  print open('/var/www/vacmon/footer.html', 'r').read()
  print '</html>'

def htmlSelector(imageSize, timeSpan, timeEnd, voName, uriTail):

  months = ['','Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']
  imageSizes = [ 300, 500, 900, 1200 ]

  print '<br clear="right">'

  print '<form name="example"><table cellspacing="5" align="center">'
  
  if imageSize not in imageSizes:
    imageSizes.append(imageSize)
    imageSizes.sort()

  if timeEnd:
    timeEndStr = '%x' % timeEnd
  else:
    timeEndStr = ''
    timeEnd = int(time.time())
      
  timeStart       = timeEnd - timeSpan
  structTimeStart = time.gmtime(timeStart)
  structTimeEnd   = time.gmtime(timeEnd)

  print '<tr><td>Start (UTC): '
  print '<input type="text" size="2" maxlength="2" name="dateFrom_hour" value="%02d">:<input ' % structTimeStart.tm_hour
  print 'type="text" size="2" maxlength="2" name="dateFrom_minute" value="%02d"> ' % structTimeStart.tm_min
    
  print '<select name="dateFrom_date">'
  for i in xrange(1,32):
    print '<option value="%d"%s>%d' % (i, ' selected' if i == structTimeStart.tm_mday else '', i)

  print '</select><select name="dateFrom_month">'
  for i in xrange(1,13):
    print '<option value="%d"%s>%s' % (i, ' selected' if i == structTimeStart.tm_mon else '', months[i])

  print '</select><select name="dateFrom_year">'
  for i in xrange(2016,2019):
    print '<option value="%d"%s>%d' % (i, ' selected' if i == structTimeStart.tm_year else '', i)
    
  print '</select>'
  print '<a href="#" onClick="calFrom.showCalendar(\'anchorFrom\',getDateString(document.forms[0].dateFrom_year,document.forms[0].dateFrom_month,document.forms[0].dateFrom_date)); return false;" TITLE="calFrom.showCalendar(\'anchorFrom\',getDateString(document.forms[0].dateFrom_year,document.forms[0].dateFrom_month,document.forms[0].dateFrom_date)); return false;" NAME="anchorFrom" ID="anchorFrom"><img src="/cal20px.png" align="absmiddle" width="20" height="20"></A>'
   
  print '</td><td style="text-align: right">Finish (UTC):'
  print '<input type="text" size="2" maxlength="2" name="dateTo_hour" value="%02d">:<input ' % structTimeEnd.tm_hour
  print 'type="text" size="2" maxlength="2" name="dateTo_minute" value="%02d"> ' % structTimeEnd.tm_min
    
  print '<select name="dateTo_date">'
  for i in xrange(1,32):
    print '<option value="%d"%s>%d' % (i, ' selected' if i == structTimeEnd.tm_mday else '', i)

  print '</select><select name="dateTo_month">'
  for i in xrange(1,13):
    print '<option value="%d"%s>%s' % (i, ' selected' if i == structTimeEnd.tm_mon else '', months[i])

  print '</select><select name="dateTo_year">'
  for i in xrange(2016,2019):
    print '<option value="%d"%s>%d' % (i, ' selected' if i == structTimeEnd.tm_year else '', i)
    
  print '</select>'
  print '<a href="#" onClick="calTo.showCalendar(\'anchorTo\',getDateString(document.forms[0].dateTo_year,document.forms[0].dateTo_month,document.forms[0].dateTo_date)); return false;" TITLE="calTo.showCalendar(\'anchorTo\',getDateString(document.forms[0].dateTo_year,document.forms[0].dateTo_month,document.forms[0].dateTo_date)); return false;" NAME="anchorTo" ID="anchorTo"><img src="/cal20px.png" align="absmiddle" width="20" height="20"></A>'

  print '<input type="button" value="Update" onclick="window.location.href=timeButtonClick(%d,\'%s\',\'%s\')">' % (imageSize, voName, uriTail)
  print '</td></tr>'


  print '<tr><td>Image size: '
  
  for i in imageSizes:
    print '<input type="button" value="%d" onclick="window.location.href=\'/%x:%x:%s:%s%s\'"> ' % \
      (i, i, timeSpan, timeEndStr, voName, uriTail)
    
  print '</td><td align="right">'

  print 'Last: '
  for txt,seconds in [('Hour',3600), ('2hr',7200), ('4hr',14400), ('Day',86400),('Week',604800),('4week',2419200),('Year',31536000)]:
    print '<input type="button" value="%s" onclick="window.location.href=\'/%x:%x::%s%s\'"> ' % \
      (txt, imageSize, seconds, voName, uriTail)
      
  print '</td></tr>'

  print '</table></form>'

  print '<div id="selectordiv" style="position:absolute;visibility:hidden;background-color:white;layer-background-color:white;"></div>'

def getBucketValue(obj):
  return obj['value'] if obj['value'] else 0

def oneFactory(imageSize, timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName, spaceName, factoryName):

  factoryFields = [ 
                    ("time_received",            "Time received",           "time"  ),
                    ("factory_heartbeat_time",   "Factory heartbeat",       "time"  ),
                    ("metadata_heartbeat_time",  "Metadata heartbeat",      "time"  ),
                    ("mjf_heartbeat_time",       "MJF heartbeat",           "time"  ),
                    ("responder_heartbeat_time", "Responder heartbeat",     "time"  ),
                    ("load_average",             "Load average",            "double"),
                    ("running_processors",       "Running processors",      "str"   ),
                    ("max_processors",           "Max processors",          "str"   ),
                    ("running_machines",         "Running machines",        "str"   ),
                    ("max_machines",             "Max machines",            "str"   ),
                    ("running_hs06",             "Running HS06",            "double"),
                    ("max_hs06",                 "Max HS06",                "double"),
                    ("boot_time",                "Boot time",               "time"  ),
                    ("daemon_version",           "Daemon version",          "str"   ),
                    ("os_issue",                 "OS version",              "str"   ),
                    ("kernel_version",           "Kernel",                  "str"   ),
                    ("mem_total_kb",             "Memory total (MiB)",      "MiB"   ),
                    ("mem_used_kb",              "Memory used (MiB)",       "MiB"   ),
                    ("swap_free_kb",             "Swap free (MiB)",         "MiB"   ),
                    ("swap_used_kb",             "Swap used (MiB)",         "MiB"   ),
                    ("root_disk_avail_inodes",   "Root disk free inodes",   "str"   ),
                    ("root_disk_avail_kb",       "Root disk free (MB)",     "MB"    ),
                    ("daemon_disk_avail_inodes", "Daemon disk free inodes", "str"   ),
                    ("daemon_disk_avail_kb",     "Daemon disk free (MB)",   "MB"    )
                  ]

  htmlHeader('VacMon ' + factoryName)

  print ('<div class="breadcrumbs"><a href="/' + sizeTimeRangeVO + '/">VacMon</a> ' +
         '/ <a href="/' + sizeTimeRangeVO + '/' + siteName + '/">' + siteName + '</a> ' +
         '/ <a href="/' + sizeTimeRangeVO + '/' + siteName + '/' + spaceName + '/">' + spaceName + '</a> ' +
         '/ ' + factoryName.split('.')[0] + '</div>')

  htmlSelector(imageSize, timeSpan, timeEnd, voName, '/' + siteName + '/' + spaceName + '/' + factoryName + '/')

  if not timeEnd:
    timeEnd = int(time.time())

  print '<h1>Factory ' + factoryName + '</h1>'

  try:
    es = elasticsearch.Elasticsearch(timeout = esTimeout)

    # Do factories search and store results

    factoryFieldsString = [('"%s"' % i[0]) for i in factoryFields]
  
    factoriesSearch =  """{
            "query":
              {
                "bool":
                {
                  "filter":
                    [
                       { "range": { "time_received": { "from": %ld, "to": %ld } } },
                       { "term":  { "site":    "%s" } },
                       { "term":  { "space":   "%s" } },
                       { "term":  { "factory": "%s" } }
                    ]
                }
              },
            "aggs" : 
              {                
                "factory_status":
                  {
                    "top_hits": { "sort": { "time_received": { "order": "desc" } }, 
                                  "size": 1, 
                                  "docvalue_fields" : [%s] }
                  },              
                "factory_histogram": 
                  {
                    "date_histogram": 
                      { 
                        "field"          : "time_received",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 1,
                        "offset"         : "+%lds"
                      },
                    "aggs":
                      {
                        "time_average":         { "avg": { "field": "time_received"        } },
                        "load_average":         { "avg": { "field": "load_average"         } },
                        "max_processors":       { "avg": { "field": "max_processors"       } },
                        "running_processors":   { "avg": { "field": "running_processors"   } },
                        "max_machines":         { "avg": { "field": "max_machines"         } },
                        "running_machines":     { "avg": { "field": "running_machines"     } },
                        "max_hs06":             { "avg": { "field": "max_hs06"             } },
                        "running_hs06":         { "avg": { "field": "running_hs06"         } },
                        "root_disk_avail_kb":   { "avg": { "field": "root_disk_avail_kb"   } },
                        "daemon_disk_avail_kb": { "avg": { "field": "daemon_disk_avail_kb" } },
                        "mem_total_kb":         { "avg": { "field": "mem_total_kb"         } },
                        "mem_used_kb":          { "avg": { "field": "mem_used_kb"          } },
                        "swap_free_kb":         { "avg": { "field": "swap_free_kb"         } },
                        "swap_used_kb":         { "avg": { "field": "swap_used_kb"         } }
                      }
                  }
              }
           }""" % (timeEnd - timeSpan, timeEnd, siteName, spaceName, factoryName, 
                   ','.join(factoryFieldsString),
                   timeSpan / timeBuckets, 
                   (timeEnd - timeSpan) - ((timeEnd - timeSpan) / (timeSpan / timeBuckets)) * (timeSpan / timeBuckets))

    fs = es.search(index = 'factories', size = 0, body = factoriesSearch)
    print '<!-- fs took %d-->' % fs['took']

    if esDebug:
      print '<pre>'
      pprint.pprint(json.loads(factoriesSearch))
      print
      pprint.pprint(fs)
      print '</pre>'

    loadAvgValues         = [0.0] * timeBuckets
    maxProcValues         = [0.0] * timeBuckets
    runningProcValues     = [0.0] * timeBuckets
    maxMachinesValues     = [0.0] * timeBuckets
    runningMachinesValues = [0.0] * timeBuckets
    maxHS06Values         = [0.0] * timeBuckets
    runningHS06Values     = [0.0] * timeBuckets
    rootDiskValues        = [0.0] * timeBuckets
    daemonDiskValues      = [0.0] * timeBuckets
    memUsedValues         = [0.0] * timeBuckets
    memFreeValues         = [0.0] * timeBuckets
    swapUsedValues        = [0.0] * timeBuckets
    swapFreeValues        = [0.0] * timeBuckets

    try:
      for bucket in fs['aggregations']['factory_histogram']['buckets']:
        i = int( ((bucket['key'] / 1000) - (timeEnd - timeSpan)) / (timeSpan / timeBuckets) )

        if i >= 0 and i < timeBuckets:
          loadAvgValues[i]         = getBucketValue(bucket['load_average'])
          maxProcValues[i]         = getBucketValue(bucket['max_processors'])
          runningProcValues[i]     = getBucketValue(bucket['running_processors'])

          maxMachinesValues[i]     = getBucketValue(bucket['max_machines'])
          runningMachinesValues[i] = getBucketValue(bucket['running_machines'])

          maxHS06Values[i]         = getBucketValue(bucket['max_hs06'])
          runningHS06Values[i]     = getBucketValue(bucket['running_hs06'])

          rootDiskValues[i]        = getBucketValue(bucket['root_disk_avail_kb']) / 1000
          daemonDiskValues[i]      = getBucketValue(bucket['daemon_disk_avail_kb']) / 1000

          memUsedValues[i]         = getBucketValue(bucket['mem_used_kb']) / 1024
          memFreeValues[i]         = (getBucketValue(bucket['mem_total_kb']) - getBucketValue(bucket['mem_used_kb'])) / 1024

          swapUsedValues[i]        = getBucketValue(bucket['swap_used_kb']) / 1024
          swapFreeValues[i]        = getBucketValue(bucket['swap_free_kb']) / 1024
    except:
      pass

    # Do machinetypes search and store results

    machinetypesSearch =  """{
            "query":
              {
                "bool":
                {
                  "filter":
                    [
                       { "range": { "time_received": { "from": %ld, "to": %ld } } },
                       { "term":  { "site":    "%s" } },
                       { "term":  { "space":   "%s" } },
                       { "term":  { "factory": "%s" } }
                    ]
                }
              },
            "aggs" : 
              {
                "machinetype_names":
                  { 
                    "terms": { "field": "machinetype", "size": 99999, "order": { "sum_running_machines": "desc" } },
                    "aggs":  { "sum_running_machines": { "sum": { "field": "running_machines" } },
                               "sum_running_hs06"    : { "sum": { "field": "running_hs06" } },
                               "shutdown":
                                 {
                                   "top_hits": { "sort": { "shutdown_time": { "order": "desc" } }, 
                                                 "size": 1, 
                                                 "docvalue_fields" : ["shutdown_time", "shutdown_message"] }
                                 },
                               "status":
                                 {
                                   "top_hits": { "sort": { "time_received": { "order": "desc" } },
                                                 "size": 1,
                                                 "docvalue_fields" : ["fqan", "num_before_fizzle",
                                                                      "running_hs06", "running_machines", "running_processors"] }
                                 }
                             }
                  },
                "machinetype_histogram": 
                  {
                    "date_histogram": 
                      { 
                        "field"          : "time_received",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 1,
                        "offset"         : "+%lds"
                      },
                    "aggs":
                      {
                        "machinetype":
                          {
                            "terms": { "field": "machinetype", "size" : 99999 },
                            "aggs":  { "running_processors": { "avg": { "field": "running_processors" } },
                                       "running_machines":   { "avg": { "field": "running_machines"   } },
                                       "running_hs06":       { "avg": { "field": "running_hs06"       } }
                                     }

                          },
                        "time_average": { "avg": { "field": "time_received" } }
                      }
                  }
              }                         
           }""" % (timeEnd - timeSpan, timeEnd, siteName, spaceName, factoryName, 
                   timeSpan / timeBuckets, 
                   (timeEnd - timeSpan) - ((timeEnd - timeSpan) / (timeSpan / timeBuckets)) * (timeSpan / timeBuckets) )

    ms = es.search(index = 'machinetypes', size = 0, body = machinetypesSearch)
    print '<!-- ms took %d -->' % ms['took']

    if esDebug:
      print '<pre>'
      pprint.pprint(json.loads(machinetypesSearch))
      print
      pprint.pprint(ms)
      print '</pre>'

    machinetypeRunningProcLists = {}
    machinetypeRunningMachinesLists = {}
    machinetypeRunningHS06Lists = {}

    for j in ms['aggregations']['machinetype_names']['buckets']:
      machinetypeRunningProcLists[j['key']]     = [0.0] * timeBuckets
      machinetypeRunningMachinesLists[j['key']] = [0.0] * timeBuckets
      machinetypeRunningHS06Lists[j['key']]     = [0.0] * timeBuckets

    try:
      for bucket in ms['aggregations']['machinetype_histogram']['buckets']:
        i = int( ((bucket['key'] / 1000) - (timeEnd - timeSpan)) / (timeSpan / timeBuckets) )

        if i >= 0 and i < timeBuckets:
          for j in bucket['machinetype']['buckets']:
            machinetypeRunningProcLists[j['key']][i]     = getBucketValue(j['running_processors'])
            machinetypeRunningMachinesLists[j['key']][i] = getBucketValue(j['running_machines'])
            machinetypeRunningHS06Lists[j['key']][i]     = getBucketValue(j['running_hs06'])
    except:
      pass

    # Turn stored results into charts
    print '<div style="text-align: center; width: 100%">'

    # Load/processors on this factory

    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets)
    chart.title = 'CPU load & running processors'
    chart.add('Load average',     loadAvgValues, fill=True, show_dots=False)
    chart.add('Running processors', runningProcValues, fill=False, show_dots=False)
    chart.add('Max processors',     maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()

    # Running processors by machinetype
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running processors by machinetype'
    for j in ms['aggregations']['machinetype_names']['buckets']:
      if j['sum_running_machines']['value'] > 0.0:
        chart.add( j['key'],
                   machinetypeRunningProcLists[j['key']],
                   fill=True, 
                   show_dots=False )

    chart.add('Max processors', maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()

    # Memory/swap on this factory

    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets)
    chart.title = 'Memory/swap'
    chart.add('Mem used (MiB)', memUsedValues, fill=True, show_dots=False)
    chart.add('Mem free (MiB)', memFreeValues, fill=True, show_dots=False)
    chart.add('Swap used (MiB)', swapUsedValues, fill=True, show_dots=False)
    chart.add('Swap free (MiB)', swapFreeValues, fill=True, show_dots=False)
    chart.htmlPrint()

    # Available disk on this factory

    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets)
    chart.title = 'Available disk'
    chart.add('Root disk free (MB)', rootDiskValues, fill=True, show_dots=False)
    chart.add('Daemon disk free (MB)', daemonDiskValues, fill=True, show_dots=False)
    chart.htmlPrint()

    # Running machines by machinetype
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running machines by machinetype'
    for j in ms['aggregations']['machinetype_names']['buckets']:
      if j['sum_running_machines']['value'] > 0.0:
        chart.add( j['key'],
                   machinetypeRunningMachinesLists[j['key']],
                   fill=True, 
                   show_dots=False )

    chart.htmlPrint()

    # Running HS06 by machinetype
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running HS06 by machinetype'
    for j in ms['aggregations']['machinetype_names']['buckets']:
      if j['sum_running_hs06']['value'] > 0.0:
        chart.add( j['key'],
                   machinetypeRunningHS06Lists[j['key']],
                   fill=True, 
                   show_dots=False )

    chart.htmlPrint()

    print '</div>'

    # Table of most recent result for this factory
    
    print '<h2>Most recent update from %s</h2>' % factoryName.split('.')[0]
    print '<table class="vacmon">'
    
    for i in factoryFields:
     try:
       if i[2] == 'double':
         s = '%.02f' % fs['aggregations']['factory_status']['hits']['hits'][0]['fields'][i[0]][0]
       elif i[2] == 'MiB':
         s = fs['aggregations']['factory_status']['hits']['hits'][0]['fields'][i[0]][0] / 1024
       elif i[2] == 'MB':
         s = fs['aggregations']['factory_status']['hits']['hits'][0]['fields'][i[0]][0] / 1000
       elif i[2] == 'time':
         s = time.strftime('%d %b %Y %H:%M UTC', time.gmtime(fs['aggregations']['factory_status']['hits']['hits'][0]['fields'][i[0]][0] / 1000))
       else:
         s = str(fs['aggregations']['factory_status']['hits']['hits'][0]['fields'][i[0]][0])
     except:
       s = ' - '

     try:
       print '<tr><td class="vacmon">%s</td><td class="vacmon">%s</td></tr>' % ( i[1], s )
     except Exception as e:
       print '<tr><td class="vacmon">%s</td></tr>' % str(e)
      
    print '</table>'

    # Table of machinetypes
    
    print '<h2>machinetypes on %s</h2>' % factoryName.split('.')[0]
    print '<table class="vacmon"><tr>'

    print '<th class="vacmon" colspan="4">Procs/machines/HS06</th>'
    print '<th class="vacmon">Last shutdown</th>'
    print '<th class="vacmon">Shutdown message</th>'
    print '<th class="vacmon">FQAN</th>'    
    print '</tr>'
    
    for j in ms['aggregations']['machinetype_names']['buckets']:
       print '<tr><td class="vacmon">%s' % j['key']

       for i in (('status',   'running_processors'),
                 ('status',   'running_machines'),
                 ('status',   'running_hs06'),
                 ('shutdown', 'shutdown_time'),
                 ('shutdown', 'shutdown_message'),
                 ('status',   'fqan')):
         print '</td><td class="vacmon">'
         
         if i[1] == 'shutdown_time':
           try:
             print time.strftime('%d %b %Y %H:%M UTC', time.gmtime(j['shutdown']['hits']['hits'][0]['fields']['shutdown_time'][0] / 1000))
           except:
             print ' - '
         else:
           try:
             print j[i[0]]['hits']['hits'][0]['fields'][i[1]][0]
           except:
             print ' - '

       print '</td></tr>'

    print '</table>'

  except Exception as e:
    print str(e)
    
  htmlFooter()
  
def oneSpace(imageSize, timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName, spaceName):

  htmlHeader('VacMon ' + spaceName)

  print ('<div class="breadcrumbs"><a href="/' + sizeTimeRangeVO + '/">VacMon</a> ' +
         '/ <a href="/' + sizeTimeRangeVO + '/' + siteName + '/">' + siteName + '</a> ' +
         '/ ' + spaceName + '</div>')
         
  htmlSelector(imageSize, timeSpan, timeEnd, voName, '/' + siteName + '/' + spaceName + '/')

  if not timeEnd:
    timeEnd = int(time.time())
                             
  print '<h1>Space ' + spaceName + '</h1>'

  try:
    es = elasticsearch.Elasticsearch(timeout = esTimeout)
  
    factoriesSearch =  """{
            "query": 
              {
                "bool":
                 {
                   "filter":
                     [
                       { "range": { "time_received": { "from": %ld, "to": %ld } } },
                       { "term":  { "site": "%s"  } },
                       { "term":  { "space": "%s" } }
                     ]
                 }
              },
            "aggs" : 
              {
                "factory_names":
                  {
                    "terms": { "field": "factory", "size" : 99999, "order" : { "_term" : "asc" } },
                    "aggs":  { "sum_running_hs06" : { "sum": { "field": "running_hs06" } },
                               "factory_status":
                                 { "top_hits": { "sort": { "time_received": { "order": "desc" } }, "size": 1, 
                                                 "docvalue_fields" : ["time_received", "boot_time", "daemon_version", "os_issue",
                                                                      "load_average", "running_processors", "max_processors",
                                                                      "running_machines", "max_machines"] } } }
                  },
                "factory_histogram": 
                  {
                    "date_histogram": 
                      { 
                        "field"          : "time_received",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 1,
                        "offset"         : "+%lds"
                      },
                    "aggs": 
                      {
                        "factory":
                          {
                            "terms": { "field": "factory", "size" : 99999 },
                            "aggs":  { "load_average":       { "avg": { "field" : "load_average"      } },
                                       "max_processors":     { "avg": { "field" : "max_processors"    } },
                                       "running_processors": { "avg": { "field": "running_processors" } },
                                       "running_machines":   { "avg": { "field": "running_machines"   } },
                                       "running_hs06":       { "avg": { "field": "running_hs06"       } }
                                     }
                          },
                        "load_average_space":       { "sum_bucket": { "buckets_path": "factory>load_average"       } },
                        "max_processors_space":     { "sum_bucket": { "buckets_path": "factory>max_processors"     } },
                        "running_processors_space": { "sum_bucket": { "buckets_path": "factory>running_processors" } },
                        "running_machines_space":   { "sum_bucket": { "buckets_path": "factory>running_machines"   } },
                        "running_hs06_space":       { "sum_bucket": { "buckets_path": "factory>running_hs06"       } }
                      }
                  }
              }
           }""" % (timeEnd - timeSpan, timeEnd, siteName, spaceName, timeSpan / timeBuckets,
                   (timeEnd - timeSpan) - ((timeEnd - timeSpan) / (timeSpan / timeBuckets)) * (timeSpan / timeBuckets) )

    fs = es.search(
          index    = 'factories',
          size     = 0,
          body     = factoriesSearch)

    print '<!-- fs took %d -->' % fs['took']

    if esDebug:
      print '<pre>'
      pprint.pprint(json.loads(factoriesSearch))
      pprint.pprint(fs)
      print '</pre>'
    
    loadAvgValues     = [0.0] * timeBuckets
    maxProcValues     = [0.0] * timeBuckets
    
    factoryLoadAvgLists = {}
    factoryRunningProcLists = {}
    factoryRunningMachinesLists = {}
    factoryRunningHS06Lists = {}

    for j in fs['aggregations']['factory_names']['buckets']:
      factoryLoadAvgLists[j['key']]         = [0.0] * timeBuckets
      factoryRunningProcLists[j['key']]     = [0.0] * timeBuckets
      factoryRunningMachinesLists[j['key']] = [0.0] * timeBuckets
      factoryRunningHS06Lists[j['key']]     = [0.0] * timeBuckets

    try:
      for bucket in fs['aggregations']['factory_histogram']['buckets']:
        i = int( ((bucket['key'] / 1000) - (timeEnd - timeSpan)) / (timeSpan / timeBuckets) )

        if i >= 0 and i < timeBuckets:
          loadAvgValues[i]     = getBucketValue(bucket['load_average_space'])
          maxProcValues[i]     = getBucketValue(bucket['max_processors_space'])

          for j in bucket['factory']['buckets']:
            factoryLoadAvgLists[j['key']][i]         = getBucketValue(j['load_average'])
            factoryRunningProcLists[j['key']][i]     = getBucketValue(j['running_processors'])
            factoryRunningMachinesLists[j['key']][i] = getBucketValue(j['running_machines'])
            factoryRunningHS06Lists[j['key']][i]     = getBucketValue(j['running_hs06'])    
    except:
      pass

    machinetypesSearch =  """{
            "query": 
              {
                "bool":
                 {
                   "filter":
                     [
                       { "range": { "time_received": { "from": %ld, "to": %ld } } },
                       { "term":  { "site": "%s"  } },
                       { "term":  { "space": "%s" } }
                     ]
                 }
              },
            "aggs": 
              {
                "machinetype_names":
                  { 
                    "terms": { "field": "machinetype", "size": 99999, "order": { "sum_running_machines": "desc" } },
                    "aggs":  { "sum_running_machines": { "sum": { "field": "running_machines" } },
                               "sum_running_hs06"    : { "sum": { "field": "running_hs06" } },
                               "shutdown":
                                 {
                                   "top_hits": { "sort": { "shutdown_time": { "order": "desc" } },
                                                 "size": 1,
                                                 "docvalue_fields" : ["shutdown_time", "shutdown_message", "factory", "fqan"] }
                                 }
                             }
                  },
                "machinetype_histogram": 
                  {
                    "date_histogram": 
                      { 
                        "field"          : "time_received",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 1,
                        "offset"         : "+%lds"
                      },
                    "aggs":
                      {
                        "machinetype":
                          {
                            "terms": { "field": "machinetype", "size" : 99999 },
                            "aggs": { "running_processors": { "sum_bucket": { "buckets_path": "factory>running_processors" } },
                                      "running_machines":   { "sum_bucket": { "buckets_path": "factory>running_machines"   } },
                                      "running_hs06":       { "sum_bucket": { "buckets_path": "factory>running_hs06"       } },
                                      "factory": {
                                                   "terms": { "field": "factory", "size" : 99999 },
                                                   "aggs":  { "running_processors": { "avg": { "field": "running_processors" } },
                                                              "running_machines":   { "avg": { "field": "running_machines"   } },
                                                              "running_hs06":       { "avg": { "field": "running_hs06"       } }
                                                            }
                                                 }
                                    }
                          }
                      }
                  }
              }
           }""" % (timeEnd - timeSpan, timeEnd, siteName, spaceName, 
                   timeSpan / timeBuckets,
                   (timeEnd - timeSpan) - ((timeEnd - timeSpan) / (timeSpan / timeBuckets)) * (timeSpan / timeBuckets) )

    ms = es.search(
          index       = 'machinetypes',
          filter_path = [ 'aggregations.machinetype_histogram.buckets.key',
                          'aggregations.machinetype_histogram.buckets.running*',
                          'aggregations.machinetype_histogram.buckets.machinetype.buckets.key',
                          'aggregations.machinetype_histogram.buckets.machinetype.buckets.running*',
                          'aggregations.vo_histogram.buckets.key',
                          'aggregations.vo_histogram.buckets.running*',
                          'aggregations.vo_histogram.buckets.vo.buckets.key',
                          'aggregations.vo_histogram.buckets.vo.buckets.running*',
                          'took',
                          'aggregations.machinetype_names.**',
                          'aggregations.vo_names.**'
                        ],
          size        = 0,
          body        = machinetypesSearch)

    print '<!-- ms took %d -->' % ms['took']

    if esDebug:
      print '<pre>'
      pprint.pprint(json.loads(machinetypesSearch))
      print
      pprint.pprint(ms)
      print '</pre>'

    machinetypeRunningProcLists = {}
    machinetypeRunningMachinesLists = {}
    machinetypeRunningHS06Lists = {}

    for j in ms['aggregations']['machinetype_names']['buckets']:
      machinetypeRunningProcLists[j['key']]     = [0.0] * timeBuckets
      machinetypeRunningMachinesLists[j['key']] = [0.0] * timeBuckets
      machinetypeRunningHS06Lists[j['key']]     = [0.0] * timeBuckets

    try:
      for bucket in ms['aggregations']['machinetype_histogram']['buckets']:
        i = int( ((bucket['key'] / 1000) - (timeEnd - timeSpan)) / (timeSpan / timeBuckets) )

        if i >= 0 and i < timeBuckets:
          for j in bucket['machinetype']['buckets']:
            machinetypeRunningProcLists[j['key']][i]     = getBucketValue(j['running_processors'])
            machinetypeRunningMachinesLists[j['key']][i] = getBucketValue(j['running_machines'])
            machinetypeRunningHS06Lists[j['key']][i]     = getBucketValue(j['running_hs06'])
    except:
      pass

    # Turn results into charts
    print '<div style="text-align: center; width: 100%">'

    # CPU load by factory

    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=4)
    chart.title = 'CPU load by factory'

    for j in fs['aggregations']['factory_names']['buckets']:
      chart.add( { 'title': j['key'].split('.')[0], 'xlink': {'href': '/%s/%s/%s/%s/' % (sizeTimeRangeVO, siteName, spaceName, j['key']) } },
                      factoryLoadAvgLists[j['key']], 
                      fill=True, 
                      show_dots=False)

    chart.htmlPrint()

    # Running processors by factory
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=4)
    chart.title = 'Running processors by factory'
    for j in fs['aggregations']['factory_names']['buckets']:
      chart.add( { 'title': j['key'].split('.')[0], 'xlink': {'href': '/%s/%s/%s/%s/' % (sizeTimeRangeVO, siteName, spaceName, j['key']) } },
                      factoryRunningProcLists[j['key']], 
                      fill=True, 
                      show_dots=False )

    chart.add('Max processors', maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # Running machines by factory
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=4)
    chart.title = 'Running machines by factory'
    for j in fs['aggregations']['factory_names']['buckets']:
      chart.add( { 'title': j['key'].split('.')[0], 'xlink': {'href': '/%s/%s/%s/%s/' % (sizeTimeRangeVO, siteName, spaceName, j['key']) } },
                      factoryRunningMachinesLists[j['key']], 
                      fill=True, 
                      show_dots=False )

    chart.htmlPrint()
    
    # Running processors by machinetype
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=4)
    chart.title = 'Running processors by machinetype'
    for j in ms['aggregations']['machinetype_names']['buckets']:
      if j['sum_running_machines']['value'] > 0.0:
        chart.add( j['key'],
                   machinetypeRunningProcLists[j['key']],
                   fill=True, 
                   show_dots=False )

    chart.add('Max processors', maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()

    # Running machines by machinetype
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=4)
    chart.title = 'Running machines by machinetype'
    for j in ms['aggregations']['machinetype_names']['buckets']:
      if j['sum_running_machines']['value'] > 0.0:
        chart.add( j['key'],
                   machinetypeRunningMachinesLists[j['key']],
                   fill=True, 
                   show_dots=False )

    chart.htmlPrint()

    print '<h2>From factories publishing HS06</h2>'

    # Running HS06 by factory
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=4)
    chart.title = 'Running HS06 by factory'
    for j in fs['aggregations']['factory_names']['buckets']:
      if j['sum_running_hs06']['value'] > 0.0:
        chart.add( { 'title': j['key'].split('.')[0], 'xlink': {'href': '/%s/%s/%s/%s/' % (sizeTimeRangeVO, siteName, spaceName, j['key']) } },
                     factoryRunningHS06Lists[j['key']], 
                     fill=True, 
                     show_dots=False )

    chart.htmlPrint()
    
    # Running HS06 by machinetype
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=4)
    chart.title = 'Running HS06 by machinetype'
    for j in ms['aggregations']['machinetype_names']['buckets']:
      if j['sum_running_hs06']['value'] > 0.0:
        chart.add( j['key'],
                   machinetypeRunningHS06Lists[j['key']],
                   fill=True, 
                   show_dots=False )

    chart.htmlPrint()
    
    print '</div>'

    # Table of most recent results for factories in this space
    
    print '<h2>Most recent update from factories in %s</h2>' % spaceName
    print '<table class="vacmon"><tr>'
    print '<th class="vacmon">Factory</th>'
    print '<th class="vacmon">Load</th>'
    print '<th class="vacmon">Procs</th>'
    print '<th class="vacmon">Machines</th>'
    print '<th class="vacmon">Last message</th>'
    print '<th class="vacmon">Daemon version</th>'
    print '<th class="vacmon">Boot time</th>'
    print '<th class="vacmon">OS version</th>'    
    print '</tr>'
    
    for j in fs['aggregations']['factory_names']['buckets']:
       print '<tr><td class="vacmon"><a href="/%s/%s/%s/%s/">%s</a>' % (sizeTimeRangeVO, siteName, spaceName, j['key'], j['key'].split('.')[0])
       
       for i in ('load_average', 'running_processors', 'running_machines',
                 'time_received', 'daemon_version', 'boot_time', 'os_issue'):
                 
         print '</td>'

         try:
           s = j['factory_status']['hits']['hits'][0]['fields'][i][0]
         except:
           print '<td class="vacmon"> - '
         else:
           if 'time' in i:
             ss = vacmon.vacutils.secondsToString(s / 1000)
           elif i == 'daemon_version':
             ss = s.replace(' vacd-factory','').replace(' vcycled','')
           elif i.startswith('running_'):
             t = j['factory_status']['hits']['hits'][0]['fields'][i.replace('running_','max_')][0]
             ss = '%d/%d' % (s, t)
           else:
             ss = s

           if i == 'time_received' and s < 1000 * (time.time() - 3600):
             print '<td class="vacmon" style="background: #ffdddd">' + str(ss)
           else:
             print '<td class="vacmon">' + str(ss)
             
       print '</td></tr>'

    print '</table>'
    
    # Table of machinetypes in this space
    
    print '<h2>Last machine shutdown by machinetype</h2>'
    print '<table class="vacmon"><tr>'
    print '<th class="vacmon">Machinetype</th>'
    print '<th class="vacmon">Last shutdown</th>'
    print '<th class="vacmon">Shutdown message</th>'
    print '<th class="vacmon">Factory</th>'
    print '<th class="vacmon">FQAN</th>'    
    print '</tr>'
    
    for j in ms['aggregations']['machinetype_names']['buckets']:
       print '<tr><td class="vacmon">%s' % j['key']

       for i in ('shutdown_time', 'shutdown_message', 'factory', 'fqan'):
         print '</td><td class="vacmon">'
         
         try:
           s = j['shutdown']['hits']['hits'][0]['fields'][i][0]
         except:
           s = ' - '
         else:
           if i == 'shutdown_time':
             s = time.strftime('%d %b %Y %H:%M UTC', time.gmtime(s / 1000))
           elif i == 'factory':
             s = '<a href="/%s/%s/%s/%s/">%s</a>' % (sizeTimeRangeVO, siteName, spaceName, s, s.split('.')[0])

         print s

       print '</td></tr>'

    print '</table>'

  except Exception as e:
    print str(e)
    
  htmlFooter()
  
def oneSite(imageSize, timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName):

  htmlHeader('VacMon ' + siteName)

  print ('<div class="breadcrumbs"><a href="/' + sizeTimeRangeVO + '/">VacMon</a> / ' + siteName + '</div>')
                             
  htmlSelector(imageSize, timeSpan, timeEnd, voName, '/' + siteName + '/')

  if not timeEnd:
    timeEnd = int(time.time())
                             
  print '<h1>Site ' + siteName + '</h1>'

  try:
    es = elasticsearch.Elasticsearch(timeout = esTimeout)
  
    factoriesSearch =  """{
            "query": 
              {
                "bool":
                 {
                   "filter":
                     [
                       { "range": { "time_received": { "from": %ld, "to": %ld } } },
                       { "match": { "site": "%s" } }
                     ]
                 }
              },
            "aggs" : 
              {
                "space_names":
                  {
                    "terms":
                      {
                        "field": "space",
                        "size" : 99999,
                        "order" : { "_term" : "asc" }
                      },
                    "aggs": { "sum_running_hs06": { "sum": { "field": "running_hs06" } } }
                  },
                "site_histogram":
                  {
                    "date_histogram": 
                      { 
                        "field"          : "time_received",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 1,
                        "offset"         : "+%lds"
                      },
                    "aggs":
                      {
                        "space":
                          {
                            "terms": { "field": "space", "size" : 99999 },
                            "aggs": { "factory": { "terms": { "field": "factory", "size" : 99999 },
                                                   "aggs":  { "max_processors":     { "avg": { "field" : "max_processors"     } },
                                                              "running_processors": { "avg": { "field" : "running_processors" } },
                                                              "running_machines":   { "avg": { "field" : "running_machines"   } },
                                                              "running_hs06":       { "avg": { "field" : "running_hs06"       } }
                                                            }
                                                 },
                                      "max_processors_space":     { "sum_bucket": { "buckets_path": "factory>max_processors"     } },
                                      "running_processors_space": { "sum_bucket": { "buckets_path": "factory>running_processors" } },
                                      "running_machines_space":   { "sum_bucket": { "buckets_path": "factory>running_machines"   } },
                                      "running_hs06_space":       { "sum_bucket": { "buckets_path": "factory>running_hs06"       } }
                                    }
                          },
                        "max_processors_site":     { "sum_bucket":  { "buckets_path": "space>max_processors_space"     } },
                        "running_processors_site": { "sum_bucket":  { "buckets_path": "space>running_processors_space" } },
                        "running_machines_site":   { "sum_bucket":  { "buckets_path": "space>running_machines_space"   } },
                        "running_hs06_site":       { "sum_bucket":  { "buckets_path": "space>running_hs06_space"       } }
                      }
                  }
              }
           }""" % (timeEnd - timeSpan, timeEnd, siteName, timeSpan / timeBuckets,
                   (timeEnd - timeSpan) - ((timeEnd - timeSpan) / (timeSpan / timeBuckets)) * (timeSpan / timeBuckets) )

    fs = es.search(
          index       = 'factories',
          size        = 0,
          filter_path = [ 'aggregations.site_histogram.buckets.key',
                          'aggregations.site_histogram.buckets.running_*',
                          'aggregations.site_histogram.buckets.max_*',
                          'aggregations.site_histogram.buckets.space.buckets.key',
                          'aggregations.site_histogram.buckets.space.buckets.running_*',
                          'aggregations.site_histogram.buckets.space.buckets.max_*',
                          'took',
                          'aggregations.space_names.**'
                        ],
          body        = factoriesSearch)

    print '<!-- fs took %d -->' % fs['took']

    if esDebug:
      print '<pre>'
      pprint.pprint(json.loads(factoriesSearch))
      print
      pprint.pprint(fs)
      print '</pre>'
    
    maxProcValues         = [0.0] * timeBuckets

    spaceRunningProcLists = {}
    spaceRunningMachinesLists = {}
    spaceRunningHS06Lists = {}

    for j in fs['aggregations']['space_names']['buckets']:
      spaceRunningProcLists[j['key']]     = [0.0] * timeBuckets
      spaceRunningMachinesLists[j['key']] = [0.0] * timeBuckets
      spaceRunningHS06Lists[j['key']]     = [0.0] * timeBuckets

    try:
      for bucket in fs['aggregations']['site_histogram']['buckets']:
        i = int( ((bucket['key'] / 1000) - (timeEnd - timeSpan)) / (timeSpan / timeBuckets) )
      
        if i >= 0 and i < timeBuckets:
           maxProcValues[i]     = getBucketValue(bucket['max_processors_site'])

           for j in bucket['space']['buckets']:
             spaceRunningProcLists[j['key']][i]     = getBucketValue(j['running_processors_space'])
             spaceRunningMachinesLists[j['key']][i] = getBucketValue(j['running_machines_space'])
             spaceRunningHS06Lists[j['key']][i]     = getBucketValue(j['running_hs06_space'])
    except:
      pass

    machinetypesSearch =  """{
            "query": 
              {
                "bool":
                 {
                   "filter":
                     [
                       { "range": { "time_received": { "from": %ld, "to": %ld } } },
                       { "term":  { "site": "%s"  } }
                     ]
                 }
              },
            "aggs": 
              {
                "vo_names":
                  { 
                    "terms": { "field": "vo", "size": 99999, "order": { "sum_running_machines": "desc" } },
                    "aggs":  { "sum_running_machines": { "sum": { "field": "running_machines" } },
                               "sum_running_hs06": { "sum": { "field": "running_hs06" } } 
                             }
                  },
                "vo_histogram": 
                  {
                    "date_histogram":
                      { 
                        "field"          : "time_received",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 1,
                        "offset"         : "+%lds"
                      },
                    "aggs":
                      {
                        "vo":
                          {
                            "terms": { "field": "vo", "size" : 99999 },
                            "aggs":  { "running_processors": { "sum_bucket": { "buckets_path": "space>running_processors" } },
                                       "running_machines":   { "sum_bucket": { "buckets_path": "space>running_machines"   } },
                                       "running_hs06":       { "sum_bucket": { "buckets_path": "space>running_hs06"       } },
                                       "space":
                                         {
                                           "terms": { "field": "space", "size": 99999 },
                                           "aggs": { "running_processors": { "sum_bucket": { "buckets_path": "machinetype>running_processors" } },
                                                     "running_machines":   { "sum_bucket": { "buckets_path": "machinetype>running_machines"   } },
                                                     "running_hs06":       { "sum_bucket": { "buckets_path": "machinetype>running_hs06"       } },
                                                     "machinetype":
                                                       {
                                                         "terms": { "field": "machinetype", "size" : 99999 },
                                                         "aggs":  { "running_processors": { "sum_bucket": { "buckets_path": "factory>running_processors" } },
                                                                    "running_machines":   { "sum_bucket": { "buckets_path": "factory>running_machines"   } },
                                                                    "running_hs06":       { "sum_bucket": { "buckets_path": "factory>running_hs06"       } },
                                                                    "factory":
                                                                      {
                                                                        "terms": { "field": "factory", "size": 99999 },
                                                                        "aggs":  { "running_processors": { "avg": { "field": "running_processors" } },
                                                                                   "running_machines":   { "avg": { "field": "running_machines"   } },
                                                                                   "running_hs06":       { "avg": { "field": "running_hs06"       } }
                                                                                 }
                                                                      }
                                                                  }
                                                       }
                                                   }
                                         }
                                     }
                          }
                      }
                  }
              }
           }""" % (timeEnd - timeSpan, timeEnd, siteName,  
                   timeSpan / timeBuckets,
                   (timeEnd - timeSpan) - ((timeEnd - timeSpan) / (timeSpan / timeBuckets)) * (timeSpan / timeBuckets) )

    ms = es.search(
          index    = 'machinetypes',
          filter_path = [
                         'aggregations.vo_histogram.buckets.key',
                         'aggregations.vo_histogram.buckets.running*',
                         'aggregations.vo_histogram.buckets.vo.buckets.key',
                         'aggregations.vo_histogram.buckets.vo.buckets.running*',
                         'took',
                         'aggregations.vo_names.**'
                        ],
          size     = 0,
          body     = machinetypesSearch)

    print '<!-- ms took %d -->' % ms['took']

    if esDebug:
      print '<pre>'
      pprint.pprint(json.loads(machinetypesSearch))
      print
      pprint.pprint(ms)
      print '</pre>'

    voRunningProcLists = {}
    voRunningMachinesLists = {}
    voRunningHS06Lists = {}

    for j in ms['aggregations']['vo_names']['buckets']:
      voRunningProcLists[j['key']]     = [0.0] * timeBuckets
      voRunningMachinesLists[j['key']] = [0.0] * timeBuckets
      voRunningHS06Lists[j['key']]     = [0.0] * timeBuckets

    try:
      for bucket in ms['aggregations']['vo_histogram']['buckets']:
        i = int( ((bucket['key'] / 1000) - (timeEnd - timeSpan)) / (timeSpan / timeBuckets) )

        if i >= 0 and i < timeBuckets:
          for j in bucket['vo']['buckets']:
            voRunningProcLists[j['key']][i]     = getBucketValue(j['running_processors'])
            voRunningMachinesLists[j['key']][i] = getBucketValue(j['running_machines'])
            voRunningHS06Lists[j['key']][i]     = getBucketValue(j['running_hs06'])
    except:
      pass

    # Turn results into charts
    print '<div style="text-align: center; width: 100%">'
    print '<p><b>Space:</b> '

    for j in fs['aggregations']['space_names']['buckets']:
      print ' <input type="button" value="%s" onclick="window.location.href=\'/%s/%s/%s/\'"> ' % (j['key'], sizeTimeRangeVO, siteName, j['key'])

    print '</p>'
   
    # Processors running at this site

    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=2)
    chart.title = 'Running processors by space'

    for j in fs['aggregations']['space_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': {'href': '/%s/%s/%s/' % (sizeTimeRangeVO, siteName, j['key']) } },
                      spaceRunningProcLists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max processors',  maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # Machines running at this site

    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=2)
    chart.title = 'Running machines by space'

    for j in fs['aggregations']['space_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': {'href': '/%s/%s/%s/' % (sizeTimeRangeVO, siteName, j['key']) } },
                      spaceRunningMachinesLists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.htmlPrint()
    
    # Running processors by VO
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running processors by VO'
    for j in ms['aggregations']['vo_names']['buckets']:
      if j['sum_running_machines']['value'] > 0.0:
        chart.add( j['key'],
                   voRunningProcLists[j['key']],
                   fill=True, 
                   show_dots=False )

    chart.add('Max processors', maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()

    # Running machines by VO
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running machines by VO'
    for j in ms['aggregations']['vo_names']['buckets']:
      if j['sum_running_machines']['value'] > 0.0:
        chart.add( j['key'],
                   voRunningMachinesLists[j['key']],
                   fill=True, 
                   show_dots=False )

    chart.htmlPrint()

    print '<h2>From spaces publishing HS06</h2>'

    # HS06 running at this site

    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=2)
    chart.title = 'Running HS06 by space'

    for j in fs['aggregations']['space_names']['buckets']:
      if j['sum_running_hs06']['value'] > 0.0:
        chart.add( { 'title': j['key'], 'xlink': {'href': '/%s/%s/%s/' % (sizeTimeRangeVO, siteName, j['key']) } },
                      spaceRunningHS06Lists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.htmlPrint()
    
    # Running HS06 by VO
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running HS06 by VO'
    for j in ms['aggregations']['vo_names']['buckets']:
      if j['sum_running_hs06']['value'] > 0.0:
        chart.add( j['key'],
                   voRunningHS06Lists[j['key']],
                   fill=True, 
                   show_dots=False )

    chart.htmlPrint()

    print '</div>'

  except Exception as e:
    print str(e)
    
  htmlFooter()
  
def allSites(imageSize, timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO):

  htmlHeader('VacMon ' + siteName)

  print ('<div class="breadcrumbs">VacMon</div>')
                             
  htmlSelector(imageSize, timeSpan, timeEnd, voName, '/')

  if not timeEnd:
    timeEnd = int(time.time())

  print '<h1>All sites</h1>'

  try:
    es = elasticsearch.Elasticsearch(timeout = esTimeout)
  
    factoriesSearch =  """{
            "query": 
              {
                "bool":
                 {
                   "filter":
                     [
                       { "range": { "time_received": { "from": %ld, "to": %ld } } }
                     ]
                 }
              },
            "aggs" : 
              {
                "site_names":
                  {
                    "terms": { "field": "site", "size" : 99999, "order" : { "sum_running_machines" : "desc" } },
                               "aggs":  { "sum_running_machines": { "sum": { "field": "running_machines" } },
                                          "sum_running_hs06"    : { "sum": { "field": "running_hs06" } } 
                                        }
                  },
                "all_histogram":
                  {
                    "date_histogram": 
                      { 
                        "field"          : "time_received",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 1,
                        "offset"         : "+%lds"
                      },
                    "aggs":
                      {
                        "site":
                          {
                            "terms": { "field": "site", "size" : 99999 },
                            "aggs":
                              {
                                "space":
                                  {
                                    "terms": { "field": "space", "size" : 99999 },
                                    "aggs":  
                                      { "factory":
                                          {
                                            "terms": { "field": "factory", "size" : 99999 },
                                            "aggs":
                                              {                                                            
                                                "time_average":       { "avg": { "field" : "time_received"      } },
                                                "max_processors":     { "avg": { "field" : "max_processors"     } },
                                                "running_processors": { "avg": { "field" : "running_processors" } },
                                                "running_machines":   { "avg": { "field" : "running_machines"   } },
                                                "running_hs06":       { "avg": { "field" : "running_hs06"       } }
                                              }
                                          },
                                        "max_processors_space":     { "sum_bucket": { "buckets_path": "factory>max_processors"     } },
                                        "running_processors_space": { "sum_bucket": { "buckets_path": "factory>running_processors" } },
                                        "running_machines_space":   { "sum_bucket": { "buckets_path": "factory>running_machines"   } },
                                        "running_hs06_space":       { "sum_bucket": { "buckets_path": "factory>running_hs06"       } }
                                      }
                                  },
                                "max_processors_site":     { "sum_bucket": { "buckets_path": "space>max_processors_space"     } },
                                "running_processors_site": { "sum_bucket": { "buckets_path": "space>running_processors_space" } },
                                "running_machines_site":   { "sum_bucket": { "buckets_path": "space>running_machines_space"   } },
                                "running_hs06_site":       { "sum_bucket": { "buckets_path": "space>running_hs06_space"       } }
                              }
                          },
                        "max_processors_all":     { "sum_bucket": { "buckets_path": "site>max_processors_site"     } },
                        "running_processors_all": { "sum_bucket": { "buckets_path": "site>running_processors_site" } },
                        "running_machines_all":   { "sum_bucket": { "buckets_path": "site>running_machines_site"   } },
                        "running_hs06_all":       { "sum_bucket": { "buckets_path": "site>running_hs06_site"       } }
                      }
                  }
              }
           }""" % (timeEnd - timeSpan, timeEnd, timeSpan / timeBuckets,
                   (timeEnd - timeSpan) - ((timeEnd - timeSpan) / (timeSpan / timeBuckets)) * (timeSpan / timeBuckets) )

    fs = es.search(
          index    = 'factories',
          size     = 0,
          filter_path = [ 'aggregations.all_histogram.buckets.key',
                          'aggregations.all_histogram.buckets.running_*',
                          'aggregations.all_histogram.buckets.max_*',
                          'aggregations.all_histogram.buckets.site.buckets.key',
                          'aggregations.all_histogram.buckets.site.buckets.running_*',
                          'aggregations.all_histogram.buckets.site.buckets.max_*',
                          'took',
                          'aggregations.site_names.**'
                        ],
          body     = factoriesSearch)

    print '<!-- fs took %d -->' % fs['took']

    if esDebug:
      print '<pre>'
      pprint.pprint(json.loads(factoriesSearch))
      print
      pprint.pprint(fs)
      print '</pre>'
    
    maxProcValues         = [0.0] * timeBuckets

    siteRunningProcLists = {}
    siteRunningMachinesLists = {}
    siteRunningHS06Lists = {}

    for j in fs['aggregations']['site_names']['buckets']:
      if j['key'] not in sitesIgnoreList:
        siteRunningProcLists[j['key']]     = [0.0] * timeBuckets
        siteRunningMachinesLists[j['key']] = [0.0] * timeBuckets
        siteRunningHS06Lists[j['key']]     = [0.0] * timeBuckets

    for bucket in fs['aggregations']['all_histogram']['buckets']:
      i = int( ((bucket['key'] / 1000) - (timeEnd - timeSpan)) / (timeSpan / timeBuckets) )

      if i >= 0 and i < timeBuckets:
         maxProcValues[i]     = getBucketValue(bucket['max_processors_all'])

         for j in bucket['site']['buckets']:
           if j['key'] not in sitesIgnoreList:
             siteRunningProcLists[j['key']][i]     = getBucketValue(j['running_processors_site'])
             siteRunningMachinesLists[j['key']][i] = getBucketValue(j['running_machines_site'])
             siteRunningHS06Lists[j['key']][i]     = getBucketValue(j['running_hs06_site'])

    machinetypesSearch =  """{
            "query": 
              {
                "bool":
                 {
                   "filter":
                     [
                       { "range": { "time_received": { "from": %ld, "to": %ld } } }
                     ]
                 }
              },
            "aggs": 
              {
                "vo_names":
                  { 
                    "terms": { "field": "vo", "size": 99999, "order": { "sum_running_machines": "desc" } },
                    "aggs":  { "sum_running_machines": { "sum": { "field": "running_machines" } } }
                  },
                "vo_histogram": 
                  {
                    "date_histogram":
                      { 
                        "field"          : "time_received",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 1,
                        "offset"         : "+%lds"
                      },
                    "aggs":
                      {                      
                        "vo":
                          {
                            "terms": { "field": "vo", "size" : 99999 },
                            "aggs":  { "running_processors": { "sum_bucket": { "buckets_path": "site>running_processors" } },
                                       "running_machines":   { "sum_bucket": { "buckets_path": "site>running_machines"   } },
                                       "running_hs06":       { "sum_bucket": { "buckets_path": "site>running_hs06"       } },
                                       "site":
                                         {
                                           "terms": { "field": "site", "size" : 99999 },
                                           "aggs":  { "running_processors": { "sum_bucket": { "buckets_path": "space>running_processors" } },
                                                      "running_machines":   { "sum_bucket": { "buckets_path": "space>running_machines"   } },
                                                      "running_hs06":       { "sum_bucket": { "buckets_path": "space>running_hs06"       } },
                                                      "space":
                                                        {
                                                          "terms": { "field": "space", "size": 99999 },
                                                          "aggs": { "running_processors": { "sum_bucket": { "buckets_path": "machinetype>running_processors" } },
                                                                    "running_machines":   { "sum_bucket": { "buckets_path": "machinetype>running_machines"   } },
                                                                    "running_hs06":       { "sum_bucket": { "buckets_path": "machinetype>running_hs06"       } },
                                                                    "machinetype":
                                                                      {
                                                                        "terms": { "field": "machinetype", "size" : 99999 },
                                                                        "aggs":  { "running_processors": { "sum_bucket": { "buckets_path": "factory>running_processors" } },
                                                                                   "running_machines":   { "sum_bucket": { "buckets_path": "factory>running_machines"   } },
                                                                                   "running_hs06":       { "sum_bucket": { "buckets_path": "factory>running_hs06"       } },
                                                                                   "factory":
                                                                                     {
                                                                                       "terms": { "field": "factory", "size": 99999 },
                                                                                       "aggs":  { "running_processors": { "avg": { "field": "running_processors" } },
                                                                                                  "running_machines":   { "avg": { "field": "running_machines"   } },
                                                                                                  "running_hs06":       { "avg": { "field": "running_hs06"       } }
                                                                                                }
                                                                                     }
                                                                                 }
                                                                      }
                                                                  }
                                                        }          
                                                    }              
                                                                  
                                         }
                                     }
                          }
                      }
                  }
              }
           }""" % (timeEnd - timeSpan, timeEnd,
                   timeSpan / timeBuckets,
                   (timeEnd - timeSpan) - ((timeEnd - timeSpan) / (timeSpan / timeBuckets)) * (timeSpan / timeBuckets) )

    ms = es.search(
          index    = 'machinetypes',
          filter_path = [
                         'aggregations.vo_histogram.buckets.key',
                         'aggregations.vo_histogram.buckets.running*',
                         'aggregations.vo_histogram.buckets.vo.buckets.key',
                         'aggregations.vo_histogram.buckets.vo.buckets.running*',
                         'took',
                         'aggregations.vo_names.**'
                        ],
          size     = 0,
          body     = machinetypesSearch)

    print '<!-- ms took %d -->' % ms['took']

    if esDebug:
      print '<pre>'
      pprint.pprint(json.loads(machinetypesSearch))
      print
      pprint.pprint(ms)
      print '</pre>'

    voRunningProcLists = {}
    voRunningMachinesLists = {}
    voRunningHS06Lists = {}

    for j in ms['aggregations']['vo_names']['buckets']:
      voRunningProcLists[j['key']]     = [0.0] * timeBuckets
      voRunningMachinesLists[j['key']] = [0.0] * timeBuckets
      voRunningHS06Lists[j['key']]     = [0.0] * timeBuckets

    for bucket in ms['aggregations']['vo_histogram']['buckets']:
       i = int( ((bucket['key'] / 1000) - (timeEnd - timeSpan)) / (timeSpan / timeBuckets) )

       if i >= 0 and i < timeBuckets:
         for j in bucket['vo']['buckets']:
           voRunningProcLists[j['key']][i]     = getBucketValue(j['running_processors'])
           voRunningMachinesLists[j['key']][i] = getBucketValue(j['running_machines'])
           voRunningHS06Lists[j['key']][i]     = getBucketValue(j['running_hs06'])    

    # Turn results into charts
    print '<div style="text-align: center; width: 100%">'        
    print '<p><b>Site:</b> '

    for j in fs['aggregations']['site_names']['buckets']:
      if j['key'] not in sitesIgnoreList:
        print ' <input type="button" value="%s" onclick="window.location.href=\'/%s/%s/\'"> ' % (j['key'], sizeTimeRangeVO, j['key'])

    print '</p>'
 
    # Processors running at all sites

    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=2)
    chart.title = 'Running processors by site'

    for j in fs['aggregations']['site_names']['buckets']:
      if j['key'] not in sitesIgnoreList:
        chart.add( { 'title': j['key'], 'xlink': { 'href':'/%s/%s/' % (sizeTimeRangeVO, j['key']) } },
                      siteRunningProcLists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max processors', maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # Machines running at all sites

    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=2)
    chart.title = 'Running machines by site'

    for j in fs['aggregations']['site_names']['buckets']:
      if j['key'] not in sitesIgnoreList:
        chart.add( { 'title': j['key'], 'xlink': { 'href': '/%s/%s/' % (sizeTimeRangeVO, j['key']) } },
                      siteRunningMachinesLists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.htmlPrint()
    
    # Running processors by VO at all sites
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running processors by VO'
    for j in ms['aggregations']['vo_names']['buckets']:
      if j['sum_running_machines']['value'] > 0.0:
        chart.add( j['key'],
                   voRunningProcLists[j['key']],
                   fill=True, 
                   show_dots=False )

    chart.add('Max processors', maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()

    # Running machines by VO at all sites
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running machines by VO'
    for j in ms['aggregations']['vo_names']['buckets']:
      if j['sum_running_machines']['value'] > 0.0:
        chart.add( j['key'],
                   voRunningMachinesLists[j['key']],
                   fill=True, 
                   show_dots=False )

    chart.htmlPrint()

    print '<h2>From sites publishing HS06</h2>'

    # HS06 running at all sites

    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets, legend_at_bottom_columns=2)
    chart.title = 'Running HS06 by site'

    for j in fs['aggregations']['site_names']['buckets']:
      if j['key'] not in sitesIgnoreList and j['sum_running_hs06']['value'] > 0.0:
        chart.add( { 'title': j['key'], 'xlink': { 'href': '/%s/%s/' % (sizeTimeRangeVO, j['key']) } },
                      siteRunningHS06Lists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.htmlPrint()

    # Running HS06 by VO at all sites
    
    chart = VacMonStackedLine(imageSize, timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running HS06 by VO'
    for j in ms['aggregations']['vo_names']['buckets']:
      if j['sum_running_machines']['value'] > 0.0:
        chart.add( j['key'],
                   voRunningHS06Lists[j['key']],
                   fill=True, 
                   show_dots=False )

    chart.htmlPrint()

    print '</div>'
    
  except Exception as e:
    print str(e)
    
  htmlFooter()
  
#
# PROGRAM MAIN
#

timeBuckets = 20

vacmonVersion = open('/var/www/vacmon/VERSION','r').readline().split('=',1)[1].strip()
requestURI    = os.environ['REQUEST_URI']

if '..' in requestURI or string.translate(requestURI, None, '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-./:') != '':
  # Redirect to main page if unacceptable characters in URI
  print 'Status: 302 Found 0'
  print 'Location: http://vacmon.gridpp.ac.uk/1f4:15180/'
  print
  sys.exit(0)

sizeTimeRangeVO, siteName, spaceName, factoryName, machinetypeName = (requestURI + '/////').split('/')[1:6]

# Static pages: main page and documentation

if not sizeTimeRangeVO:
  htmlHeader('VacMon', selector=False)

  try:
    print open('/var/www/vacmon/index.html', 'r').read()
  except:
    pass  

  htmlFooter()
  sys.exit(0)

# Parse size, time range, VO
splitSizeTimeRangeVO = (sizeTimeRangeVO + ':::').split(':')

reload = False

try:
  imageSize = int(splitSizeTimeRangeVO[0], 16)
except:
  reload = True
  imageSize = 600

try:
  timeSpan = int(splitSizeTimeRangeVO[1], 16)
  
  if timeSpan / timeBuckets < 300:
    # Buckets cannot be less than 5min (300s)
    timeBuckets = timeSpan / 300
  
  if timeSpan % timeBuckets != 0:
    # Must be divisible by timeBuckets!      
    timeSpan = (timeSpan / timeBuckets) * timeBuckets
    reload = True
except:
  # Must be divisible by timeBuckets!
  timeSpan = (86400 / timeBuckets) * timeBuckets
  reload = True
  
if reload:
  timeEnd = ''
elif splitSizeTimeRangeVO[2] == '':
  timeEnd = ''
else:
  try:
    timeEnd = int(splitSizeTimeRangeVO[2], 16)
  except:
    timeEnd = ''
    reload = True

voName = splitSizeTimeRangeVO[3]

if reload:
  print 'Status: 302 Found'
  print ('Location: http://vacmon.gridpp.ac.uk/%x:%x:%s:%s/' % (imageSize, timeSpan, str(timeEnd), voName)) + \
         ((siteName        + '/') if siteName        else '') + \
         ((spaceName       + '/') if spaceName       else '') + \
         ((factoryName     + '/') if factoryName     else '')
  print
  sys.exit(0)

# Pages with graphs

if siteName and spaceName and factoryName:
  oneFactory(imageSize, timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName, spaceName, factoryName)

elif siteName and spaceName:
  oneSpace(imageSize, timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName, spaceName)

elif siteName:
  oneSite(imageSize, timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName)

else:
  allSites(imageSize, timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO)

sys.exit(0)
