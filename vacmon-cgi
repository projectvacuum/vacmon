#!/usr/bin/python
#
#  viabmon-cgi - Vacmon CGI script
#
#  Andrew McNab, University of Manchester.
#  Copyright (c) 2015-6. All rights reserved.
#
#  Redistribution and use in source and binary forms, with or
#  without modification, are permitted provided that the following
#  conditions are met:
#
#    o Redistributions of source code must retain the above
#      copyright notice, this list of conditions and the following
#      disclaimer. 
#    o Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials
#      provided with the distribution. 
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
#  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
#  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
#  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
#  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
#  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
#  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.
#
#  Contacts: Andrew.McNab@cern.ch  http://www.gridpp.ac.uk/vacproject/
#

import os
import cgi
import sys
import time
import json
import pygal
import string
import pprint
import elasticsearch

class VacMonStackedLine(pygal.StackedLine):

  def __init__(self, timeSpan, timeEnd, timeBuckets):
        pygal.StackedLine.__init__(self, include_x_axis=True, stroke_style={'width': 2}, legend_at_bottom=True, show_x_guides=True, style=pygal.style.LightColorizedStyle, x_label_rotation=30)

        self.x_labels = [ (timeEnd - timeSpan + (i + 0.5) * (timeSpan / timeBuckets)) for i in range(0, timeBuckets) ]

  def _points(self, x_pos):
        # Unfilled series to be overlayed rather than stacked
        """
        Convert given data values into drawable points (x, y)
        and interpolated points if interpolate option is specified
        """
        for series_group in (self.series, self.secondary_series):
            accumulation = [0] * self._len
            for serie in series_group[::-1 if self.stack_from_top else 1]:
              if serie.fill == False: # <--- this is the significant change
                serie.points = [ (x_pos[i], v) for i, v in enumerate(serie.values) ]
                if serie.points and self.interpolate:
                    serie.interpolated = self._interpolate(x_pos, serie.values)
                else:
                    serie.interpolated = []                
              else:
                accumulation = list(map(sum, zip(accumulation, serie.values)))
                serie.points = [
                    (x_pos[i], v)
                    for i, v in enumerate(accumulation)]
                if serie.points and self.interpolate:
                    serie.interpolated = self._interpolate(x_pos, accumulation)
                else:
                    serie.interpolated = []

  def htmlPrint(self):
        print '<figure>'
        print self.render()
        print '</figure>'

def htmlHeader(title):
  print 'Status: 200 OK'
  print 'Content-Type: text/html'
  print
  print '<html><head><title>' + title + '</title>'
  print open('/var/www/vacmon/header.html', 'r').read()

def htmlFooter():
  print open('/var/www/vacmon/footer.html', 'r').read()
  print '</html>'

def getBucketValue(obj):
  return obj['value'] if obj['value'] else 0

def oneFactory(timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName, spaceName, factoryName):

  htmlHeader('VacMon ' + factoryName)

  print ('<div class="breadcrumbs"><a href="/' + sizeTimeRangeVO + '/">VacMon</a> ' +
         '/ <a href="/' + sizeTimeRangeVO + '/' + siteName + '/">' + siteName + '</a> ' +
         '/ <a href="/' + sizeTimeRangeVO + '/' + siteName + '/' + spaceName + '/">' + spaceName + '</a> ' +
         '/ ' + factoryName.split('.')[0] + '</div>')
                             
  print '<h1>Factory ' + factoryName + '</h1>'

  try:
    es = elasticsearch.Elasticsearch()
  
    factoriesSearch =  """{
            "query":
              {
                "bool":
                {
                  "filter":
                    [
                       { "range": { "time_received": { "from": %ld, "to": %ld } } },
                       { "term":  { "site":    "%s" } },
                       { "term":  { "space":   "%s" } },
                       { "term":  { "factory": "%s" } }
                    ]
                }
              },
            "aggs" : 
              {
                "factory_histogram": 
                  {
                    "date_histogram": 
                      { 
                        "field"          : "time_received",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 0,
                        "offset"         : "+%lds",
                        "extended_bounds": { "min": %ld, "max": %ld }
                      },
                    "aggs":
                      {
                        "time_average":         { "avg": { "field": "time_received"        } },
                        "load_average":         { "avg": { "field": "load_average"         } },
                        "max_processors":       { "avg": { "field": "max_processors"       } },
                        "running_processors":   { "avg": { "field": "running_processors"   } },
                        "max_machines":         { "avg": { "field": "max_machines"         } },
                        "running_machines":     { "avg": { "field": "running_machines"     } },
                        "max_hs06":             { "avg": { "field": "max_hs06"             } },
                        "running_hs06":         { "avg": { "field": "running_hs06"         } },
                        "root_disk_avail_kb":   { "avg": { "field": "root_disk_avail_kb"   } },
                        "daemon_disk_avail_kb": { "avg": { "field": "daemon_disk_avail_kb" } },
                        "mem_total_kb":         { "avg": { "field": "mem_total_kb"         } },
                        "mem_used_kb":          { "avg": { "field": "mem_used_kb"          } },
                        "swap_free_kb":         { "avg": { "field": "swap_free_kb"         } },
                        "swap_used_kb":         { "avg": { "field": "swap_used_kb"         } }
                      }
                  }
              }                         
           }""" % (timeEnd - timeSpan, timeEnd, siteName, spaceName, factoryName, timeSpan / timeBuckets, 
                   (timeEnd - timeSpan) - ((timeEnd - timeSpan) / (timeSpan / timeBuckets)) * (timeSpan / timeBuckets),
                   (timeEnd - timeSpan) * 1000, timeEnd * 1000)

    print '<pre>'
    pprint.pprint(json.loads(factoriesSearch))

    fs = es.search(index = 'vacmon', doc_type = 'factories', size = 0, body = factoriesSearch)

    pprint.pprint(fs)
    print '</pre>'
    
    machinetypesSearch =  """{
            "query":
              {
                "bool":
                {
                  "filter":
                    [
                       { "range": { "time_received": { "from": %ld, "to": %ld } } },
                       { "term":  { "site":    "%s" } },
                       { "term":  { "space":   "%s" } },
                       { "term":  { "factory": "%s" } }
                    ]
                }
              },
            "aggs" : 
              {
                "machinetype_histogram": 
                  {
                    "date_histogram": 
                      { 
                        "field"          : "time_received",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 0,
                        "offset"         : "+%ld",
                        "extended_bounds": { "min": %ld, "max": %ld }
                      },
                    "aggs":
                      {
                        "machinetype":
                          {
                            "terms": { "field": "machinetype", "size" : 99999 },
                            "aggs":  { "running_processors": { "avg": { "field": "running_processors" } },
                                       "running_machines":   { "avg": { "field": "running_machines"   } },
                                       "running_hs06":       { "avg": { "field": "running_hs06"       } }
                                     }

                          },                      
                        "time_average": { "avg": { "field": "time_received" } }
                      }
                  }
              }                         
           }""" % (timeEnd - timeSpan, timeEnd, siteName, spaceName, factoryName, timeSpan / timeBuckets, 
                   (timeEnd - timeSpan) - ((timeEnd - timeSpan) / (timeSpan / timeBuckets)) * (timeSpan / timeBuckets),
                   (timeEnd - timeSpan) * 1000, timeEnd * 1000)

    print '<pre>'
#    pprint.pprint(json.loads(machinetypesSearch))

#    ms = es.search(index = 'vacmon', doc_type = 'machinetypes', size = 0, body = machinetypesSearch)

#    pprint.pprint(ms)
    print '</pre>'
    
    loadAvgValues         = [0.0] * timeBuckets
    maxProcValues         = [0.0] * timeBuckets
    runningProcValues     = [0.0] * timeBuckets
    maxMachinesValues     = [0.0] * timeBuckets
    runningMachinesValues = [0.0] * timeBuckets
    maxHS06Values         = [0.0] * timeBuckets
    runningHS06Values     = [0.0] * timeBuckets
    rootDiskValues        = [0.0] * timeBuckets
    daemonDiskValues      = [0.0] * timeBuckets
    memUsedValues         = [0.0] * timeBuckets
    memFreeValues         = [0.0] * timeBuckets
    swapUsedValues        = [0.0] * timeBuckets
    swapFreeValues        = [0.0] * timeBuckets

    for bucket in fs['aggregations']['factory_histogram']['buckets']:
       i = int( ((bucket['key'] / 1000) - (timeEnd - timeSpan)) / (timeSpan / timeBuckets) )

       if i >= 0 and i < timeBuckets:
         loadAvgValues[i]         = getBucketValue(bucket['load_average'])
         maxProcValues[i]         = getBucketValue(bucket['max_processors'])
         runningProcValues[i]     = getBucketValue(bucket['running_processors'])

         maxMachinesValues[i]     = getBucketValue(bucket['max_machines'])
         runningMachinesValues[i] = getBucketValue(bucket['running_machines'])

         maxHS06Values[i]         = getBucketValue(bucket['max_hs06'])
         runningHS06Values[i]     = getBucketValue(bucket['running_hs06'])

         rootDiskValues[i]        = getBucketValue(bucket['root_disk_avail_kb']) / 1000
         daemonDiskValues[i]      = getBucketValue(bucket['daemon_disk_avail_kb']) / 1000

         memUsedValues[i]         = getBucketValue(bucket['mem_used_kb']) / 1024
         memFreeValues[i]         = (getBucketValue(bucket['mem_total_kb']) - getBucketValue(bucket['mem_used_kb'])) / 1024

         swapUsedValues[i]        = getBucketValue(bucket['swap_used_kb']) / 1024
         swapFreeValues[i]        = getBucketValue(bucket['swap_free_kb']) / 1024

    # Load/processors on this factory

    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'CPU load & processors on factory ' + factoryName
    chart.add('Load average',     loadAvgValues, fill=True, show_dots=False)
    chart.add('Running processors', runningProcValues, fill=False, show_dots=False)
    chart.add('Max processors',     maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()

    # Machines on this factory

    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'Machines on factory ' + factoryName
    chart.add('Running machines', runningMachinesValues, fill=True, show_dots=False)
    chart.add('Max machines',     maxMachinesValues, fill=False, show_dots=False)
    chart.htmlPrint()

    # HS06 on this factory

    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'HS06 on factory ' + factoryName
    chart.add('Running HS06', runningHS06Values, fill=True, show_dots=False)
    chart.add('Max HS06',     maxHS06Values, fill=False, show_dots=False)
    chart.htmlPrint()

    # Available disk on this factory

    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'Available disk on factory ' + factoryName
    chart.add('Root disk free (MB)', rootDiskValues, fill=True, show_dots=False)
    chart.add('Daemon disk free (MB)', daemonDiskValues, fill=True, show_dots=False)
    chart.htmlPrint()

    # Memory/swap on this factory

    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'Memory/swap on factory ' + factoryName
    chart.add('Mem used (MiB)', memUsedValues, fill=True, show_dots=False)
    chart.add('Mem free (MiB)', memFreeValues, fill=True, show_dots=False)
    chart.add('Swap used (MiB)', swapUsedValues, fill=True, show_dots=False)
    chart.add('Swap free (MiB)', swapFreeValues, fill=True, show_dots=False)
    chart.htmlPrint()

  except Exception as e:
    print str(e)
    
  htmlFooter()
  
def oneSpace(timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName, spaceName):

  htmlHeader('VacMon ' + spaceName)

  print ('<div class="breadcrumbs"><a href="/' + sizeTimeRangeVO + '/">VacMon</a> ' +
         '/ <a href="/' + sizeTimeRangeVO + '/' + siteName + '/">' + siteName + '</a> ' +
         '/ ' + spaceName + '</div>')
                             
  print '<h1>Space ' + spaceName + '</h1>'

  try:
    es = elasticsearch.Elasticsearch()
  
    searchBody =  """{
            "query": 
              {
                "bool":
                 {
                   "filter":
                     [
                       { "range": { "time_received": { "from": %ld, "to": %ld } } },
                       { "term":  { "site": "%s"  } },
                       { "term":  { "space": "%s" } }
                     ]
                 }
              },
            "aggs" : 
              {
                "factory_names":
                  {
                    "terms":
                      {
                        "field": "factory",
                        "size" : 99999,
                        "order" : { "_term" : "asc" }
                      }
                  },
                "space_histogram": 
                  {
                    "date_histogram": 
                      { 
                        "field"          : "time_received",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 0,
                        "offset"         : "+%lds",
                        "extended_bounds": { "min": %ld, "max": %ld }
                      },
                    "aggs": 
                      {
                        "factory":
                          {
                            "terms": { "field": "factory", "size" : 99999 },
                            "aggs":  { "time_average":       { "avg": { "field": "time_received"      } },
                                       "load_average":       { "avg": { "field" : "load_average"      } },
                                       "max_processors":     { "avg": { "field" : "max_processors"    } },
                                       "running_processors": { "avg": { "field": "running_processors" } },
                                       "max_machines":       { "avg": { "field": "max_machines"       } },
                                       "running_machines":   { "avg": { "field": "running_machines"   } },
                                       "max_hs06":           { "avg": { "field": "max_hs06"           } },
                                       "running_hs06":       { "avg": { "field": "running_hs06"       } }
                                     }
                          },
                        "load_average_space":       { "sum_bucket": { "buckets_path": "factory>load_average"       } },
                        "max_processors_space":     { "sum_bucket": { "buckets_path": "factory>max_processors"     } },
                        "running_processors_space": { "sum_bucket": { "buckets_path": "factory>running_processors" } },
                        "max_machines_space":       { "sum_bucket": { "buckets_path": "factory>max_machines"       } },
                        "running_machines_space":   { "sum_bucket": { "buckets_path": "factory>running_machines"   } },
                        "max_hs06_space":           { "sum_bucket": { "buckets_path": "factory>max_hs06"           } },
                        "running_hs06_space":       { "sum_bucket": { "buckets_path": "factory>running_hs06"       } }
                      }
                  }
              }
           }""" % (timeEnd - timeSpan, timeEnd, siteName, spaceName, timeSpan / timeBuckets,
                   (timeEnd - timeSpan) - ((timeEnd - timeSpan) / (timeSpan / timeBuckets)) * (timeSpan / timeBuckets),
                   (timeEnd - timeSpan) * 1000, timeEnd * 1000)

    print '<pre>'
    pprint.pprint(json.loads(searchBody))

    t = es.search(
          index    = 'vacmon',
          doc_type = 'factories',
          size     = 0,
          body     = searchBody)

    pprint.pprint(t)
    print '</pre>'
    
    loadAvgValues     = [0.0] * timeBuckets
    maxProcValues     = [0.0] * timeBuckets
    maxMachinesValues = [0.0] * timeBuckets
    maxHS06Values     = [0.0] * timeBuckets
    
    factoryLoadAvgLists = {}
    factoryRunningProcLists = {}
    factoryRunningMachinesLists = {}
    factoryRunningHS06Lists = {}

    for j in t['aggregations']['factory_names']['buckets']:
      factoryLoadAvgLists[j['key']]         = [0.0] * timeBuckets
      factoryRunningProcLists[j['key']]     = [0.0] * timeBuckets
      factoryRunningMachinesLists[j['key']] = [0.0] * timeBuckets
      factoryRunningHS06Lists[j['key']]     = [0.0] * timeBuckets

    for bucket in t['aggregations']['space_histogram']['buckets']:
       i = int( ((bucket['key'] / 1000) - (timeEnd - timeSpan)) / (timeSpan / timeBuckets) )

       if i >= 0 and i < timeBuckets:
         loadAvgValues[i]     = getBucketValue(bucket['load_average_space'])
         maxProcValues[i]     = getBucketValue(bucket['max_processors_space'])
         maxMachinesValues[i] = getBucketValue(bucket['max_machines_space'])
         maxHS06Values[i]     = getBucketValue(bucket['max_hs06_space'])

         for j in bucket['factory']['buckets']:
           factoryLoadAvgLists[j['key']][i]         = getBucketValue(j['load_average'])
           factoryRunningProcLists[j['key']][i]     = getBucketValue(j['running_processors'])
           factoryRunningMachinesLists[j['key']][i] = getBucketValue(j['running_machines'])
           factoryRunningHS06Lists[j['key']][i]     = getBucketValue(j['running_hs06'])

    # CPU load per factory

    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'CPU load in space ' + spaceName

    for j in t['aggregations']['factory_names']['buckets']:
      chart.add( { 'title': j['key'].split('.')[0], 'xlink': {'href': '/%s/%s/%s/%s/' % (sizeTimeRangeVO, siteName, spaceName, j['key']) } },
                      factoryLoadAvgLists[j['key']], 
                      fill=True, 
                      show_dots=False)

    chart.add('Max processors', maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()

    # Running processors per factory
    
    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'Processors in space ' + spaceName
    for j in t['aggregations']['factory_names']['buckets']:
      chart.add( { 'title': j['key'].split('.')[0], 'xlink': {'href': '/%s/%s/%s/%s/' % (sizeTimeRangeVO, siteName, spaceName, j['key']) } },
                      factoryRunningProcLists[j['key']], 
                      fill=True, 
                      show_dots=False )

    chart.add('Max processors', maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # Running machines per factory
    
    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'Machines in space ' + spaceName
    for j in t['aggregations']['factory_names']['buckets']:
      chart.add( { 'title': j['key'].split('.')[0], 'xlink': {'href': '/%s/%s/%s/%s/' % (sizeTimeRangeVO, siteName, spaceName, j['key']) } },
                      factoryRunningMachinesLists[j['key']], 
                      fill=True, 
                      show_dots=False )

    chart.add('Max machines', maxMachinesValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # Running HS06 per factory
    
    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'HS06 in space ' + spaceName
    for j in t['aggregations']['factory_names']['buckets']:
      chart.add( { 'title': j['key'].split('.')[0], 'xlink': {'href': '/%s/%s/%s/%s/' % (sizeTimeRangeVO, siteName, spaceName, j['key']) } },
                      factoryRunningHS06Lists[j['key']], 
                      fill=True, 
                      show_dots=False )

    chart.add('Max HS06', maxHS06Values, fill=False, show_dots=False)
    chart.htmlPrint()
    
  except Exception as e:
    print str(e)
    
  htmlFooter()
  
def oneSite(timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName):

  htmlHeader('VacMon ' + siteName)

  print ('<div class="breadcrumbs"><a href="/' + sizeTimeRangeVO + '/">VacMon</a> / ' + siteName + '</div>')
                             
  print '<h1>Site ' + siteName + '</h1>'

  try:
    es = elasticsearch.Elasticsearch()
  
    searchBody =  """{
            "query": 
              {
                "bool":
                 {
                   "filter":
                     [
                       { "range": { "time_received": { "from": %ld, "to": %ld } } },
                       { "match": { "site": "%s" } }
                     ]
                 }
              },
            "aggs" : 
              {
                "space_names":
                  {
                    "terms":
                      {
                        "field": "space",
                        "size" : 99999,
                        "order" : { "_term" : "asc" }
                      }
                  },
                "site_histogram":
                  {
                    "date_histogram": 
                      { 
                        "field"          : "time_received",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 0,
                        "offset"         : "+%lds",
                        "extended_bounds": { "min": %ld, "max": %ld }
                      },
                    "aggs":
                      {
                        "space":
                          {
                            "terms": { "field": "space", "size" : 99999 },
                            "aggs": { "factory": { "terms": { "field": "factory", "size" : 99999 },
                                                   "aggs":  { "time_average":       { "avg": { "field": "time_received"       } },
                                                              "max_processors":     { "avg": { "field" : "max_processors"     } },
                                                              "running_processors": { "avg": { "field" : "running_processors" } },
                                                              "max_machines":       { "avg": { "field" : "max_machines"       } },
                                                              "running_machines":   { "avg": { "field" : "running_machines"   } },
                                                              "max_hs06":           { "avg": { "field" : "max_hs06"           } },
                                                              "running_hs06":       { "avg": { "field" : "running_hs06"       } }
                                                            }
                                                 },
                                      "max_processors_space":     { "sum_bucket": { "buckets_path": "factory>max_processors"     } },
                                      "running_processors_space": { "sum_bucket": { "buckets_path": "factory>running_processors" } },
                                      "max_machines_space":       { "sum_bucket": { "buckets_path": "factory>max_machines"       } },
                                      "running_machines_space":   { "sum_bucket": { "buckets_path": "factory>running_machines"   } },
                                      "max_hs06_space":           { "sum_bucket": { "buckets_path": "factory>max_hs06"           } },
                                      "running_hs06_space":       { "sum_bucket": { "buckets_path": "factory>running_hs06"       } }
                                    }
                          },
                        "max_processors_site":     { "sum_bucket":  { "buckets_path": "space>max_processors_space"     } },
                        "running_processors_site": { "sum_bucket":  { "buckets_path": "space>running_processors_space" } },
                        "max_machines_site":       { "sum_bucket":  { "buckets_path": "space>max_machines_space"       } },
                        "running_machines_site":   { "sum_bucket":  { "buckets_path": "space>running_machines_space"   } },
                        "max_hs06_site":           { "sum_bucket":  { "buckets_path": "space>max_hs06_space"           } },
                        "running_hs06_site":       { "sum_bucket":  { "buckets_path": "space>running_hs06_space"       } }
                      }
                  }
              }
           }""" % (timeEnd - timeSpan, timeEnd, siteName, timeSpan / timeBuckets,
                   (timeEnd - timeSpan) - ((timeEnd - timeSpan) / (timeSpan / timeBuckets)) * (timeSpan / timeBuckets),
                   (timeEnd - timeSpan) * 1000, timeEnd * 1000)

    print '<pre>'
#    pprint.pprint(json.loads(searchBody))

    t = es.search(
          index    = 'vacmon',
          doc_type = 'factories',
          size     = 0,
          body     = searchBody)

#    pprint.pprint(t)
    print '</pre>'
    
    maxProcValues         = [0.0] * timeBuckets
    maxMachinesValues     = [0.0] * timeBuckets
    maxHS06Values         = [0.0] * timeBuckets

    spaceRunningProcLists = {}
    spaceRunningMachinesLists = {}
    spaceRunningHS06Lists = {}

    for j in t['aggregations']['space_names']['buckets']:
      spaceRunningProcLists[j['key']]     = [0.0] * timeBuckets
      spaceRunningMachinesLists[j['key']] = [0.0] * timeBuckets
      spaceRunningHS06Lists[j['key']]     = [0.0] * timeBuckets

    for bucket in t['aggregations']['site_histogram']['buckets']:
      i = int( ((bucket['key'] / 1000) - (timeEnd - timeSpan)) / (timeSpan / timeBuckets) )
      
      if i >= 0 and i < timeBuckets:
         maxProcValues[i]     = getBucketValue(bucket['max_processors_site'])
         maxMachinesValues[i] = getBucketValue(bucket['max_machines_site'])
         maxHS06Values[i]     = getBucketValue(bucket['max_hs06_site'])

         for j in bucket['space']['buckets']:
           spaceRunningProcLists[j['key']][i]     = getBucketValue(j['running_processors_space'])
           spaceRunningMachinesLists[j['key']][i] = getBucketValue(j['running_machines_space'])
           spaceRunningHS06Lists[j['key']][i]     = getBucketValue(j['running_hs06_space'])

    # Processors running at this site

    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running processors at site ' + siteName

    for j in t['aggregations']['space_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': {'href': '/%s/%s/%s/' % (sizeTimeRangeVO, siteName, j['key']) } },
                      spaceRunningProcLists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max processors',  maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # Machines running at this site

    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running machines at site ' + siteName

    for j in t['aggregations']['space_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': {'href': '/%s/%s/%s/' % (sizeTimeRangeVO, siteName, j['key']) } },
                      spaceRunningMachinesLists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max machines',  maxMachinesValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # HS06 running at this site

    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running HS06 at site ' + siteName

    for j in t['aggregations']['space_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': {'href': '/%s/%s/%s/' % (sizeTimeRangeVO, siteName, j['key']) } },
                      spaceRunningHS06Lists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max HS06',  maxHS06Values, fill=False, show_dots=False)
    chart.htmlPrint()
    
  except Exception as e:
    print str(e)
    
  htmlFooter()
  
def allSites(timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO):

  htmlHeader('VacMon ' + siteName)

  print ('<div class="breadcrumbs">VacMon</div>')
                             
  print '<h1>All sites</h1>'

  try:
    es = elasticsearch.Elasticsearch()
  
    searchBody =  """{
            "query": 
              {
                "bool":
                 {
                   "filter":
                     [
                       { "range": { "time_received": { "from": %ld, "to": %ld } } }
                     ]
                 }
              },
            "aggs" : 
              {
                "site_names":
                  {
                    "terms": { "field": "site", "size" : 99999, "order" : { "_term" : "asc" } }
                  },
                "all_histogram":
                  {
                    "date_histogram": 
                      { 
                        "field"          : "time_received",
                        "interval"       : "%ds",
                        "format"         : "epoch_second",
                        "min_doc_count"  : 0,
                        "offset"         : "+%lds",
                        "extended_bounds": { "min": %ld, "max": %ld }
                      },
                    "aggs":
                      {
                        "site":
                          {
                            "terms": { "field": "site", "size" : 99999 },
                            "aggs":
                              {
                                "space":
                                  {
                                    "terms": { "field": "space", "size" : 99999 },
                                    "aggs":  
                                      { "factory":
                                          {
                                            "terms": { "field": "factory", "size" : 99999 },
                                            "aggs":
                                              {                                                            
                                                "time_average":       { "avg": { "field" : "time_received"      } },
                                                "max_processors":     { "avg": { "field" : "max_processors"     } },
                                                "running_processors": { "avg": { "field" : "running_processors" } },
                                                "max_machines":       { "avg": { "field" : "max_machines"       } },
                                                "running_machines":   { "avg": { "field" : "running_machines"   } },
                                                "max_hs06":           { "avg": { "field" : "max_hs06"           } },
                                                "running_hs06":       { "avg": { "field" : "running_hs06"       } }
                                              }
                                          },
                                        "max_processors_space":     { "sum_bucket": { "buckets_path": "factory>max_processors"     } },
                                        "running_processors_space": { "sum_bucket": { "buckets_path": "factory>running_processors" } },
                                        "max_machines_space":       { "sum_bucket": { "buckets_path": "factory>max_machines"       } },
                                        "running_machines_space":   { "sum_bucket": { "buckets_path": "factory>running_machines"   } },
                                        "max_hs06_space":           { "sum_bucket": { "buckets_path": "factory>max_hs06"           } },
                                        "running_hs06_space":       { "sum_bucket": { "buckets_path": "factory>running_hs06"       } }
                                      }
                                  },
                                "max_processors_site":     { "sum_bucket": { "buckets_path": "space>max_processors_space"     } },
                                "running_processors_site": { "sum_bucket": { "buckets_path": "space>running_processors_space" } },
                                "max_machines_site":       { "sum_bucket": { "buckets_path": "space>max_machines_space"       } },
                                "running_machines_site":   { "sum_bucket": { "buckets_path": "space>running_machines_space"   } },
                                "max_hs06_site":           { "sum_bucket": { "buckets_path": "space>max_hs06_space"           } },
                                "running_hs06_site":       { "sum_bucket": { "buckets_path": "space>running_hs06_space"       } }
                              }
                          },
                        "max_processors_all":     { "sum_bucket": { "buckets_path": "site>max_processors_site"     } },
                        "running_processors_all": { "sum_bucket": { "buckets_path": "site>running_processors_site" } },
                        "max_machines_all":       { "sum_bucket": { "buckets_path": "site>max_machines_site"       } },
                        "running_machines_all":   { "sum_bucket": { "buckets_path": "site>running_machines_site"   } },
                        "max_hs06_all":           { "sum_bucket": { "buckets_path": "site>max_hs06_site"           } },
                        "running_hs06_all":       { "sum_bucket": { "buckets_path": "site>running_hs06_site"       } }
                      }
                  }
              }
           }""" % (timeEnd - timeSpan, timeEnd, timeSpan / timeBuckets, 
                   (timeEnd - timeSpan) - ((timeEnd - timeSpan) / (timeSpan / timeBuckets)) * (timeSpan / timeBuckets),
                   (timeEnd - timeSpan) * 1000, timeEnd * 1000)

    print '<pre>'
#    pprint.pprint(json.loads(searchBody))

    t = es.search(
          index    = 'vacmon',
          doc_type = 'factories',
          size     = 0,
          body     = searchBody)

#    pprint.pprint(t)
    print '</pre>'
    
    maxProcValues         = [0.0] * timeBuckets
    maxMachinesValues     = [0.0] * timeBuckets
    maxHS06Values         = [0.0] * timeBuckets

    siteRunningProcLists = {}
    siteRunningMachinesLists = {}
    siteRunningHS06Lists = {}

    for j in t['aggregations']['site_names']['buckets']:
      siteRunningProcLists[j['key']]     = [0.0] * timeBuckets
      siteRunningMachinesLists[j['key']] = [0.0] * timeBuckets
      siteRunningHS06Lists[j['key']]     = [0.0] * timeBuckets

    for bucket in t['aggregations']['all_histogram']['buckets']:
      i = int( ((bucket['key'] / 1000) - (timeEnd - timeSpan)) / (timeSpan / timeBuckets) )

      if i >= 0 and i < timeBuckets:
         maxProcValues[i]     = getBucketValue(bucket['max_processors_all'])
         maxMachinesValues[i] = getBucketValue(bucket['max_machines_all'])
         maxHS06Values[i]     = getBucketValue(bucket['max_hs06_all'])

         for j in bucket['site']['buckets']:
           siteRunningProcLists[j['key']][i]     = getBucketValue(j['running_processors_site'])
           siteRunningMachinesLists[j['key']][i] = getBucketValue(j['running_machines_site'])
           siteRunningHS06Lists[j['key']][i]     = getBucketValue(j['running_hs06_site'])

    # Processors running at all sites

    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running processors'

    for j in t['aggregations']['site_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': { 'href':'/%s/%s/' % (sizeTimeRangeVO, j['key']) } },
                      siteRunningProcLists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max processors', maxProcValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # Machines running at all sites

    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running machines'

    for j in t['aggregations']['site_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': { 'href': '/%s/%s/' % (sizeTimeRangeVO, j['key']) } },
                      siteRunningMachinesLists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max machines', maxMachinesValues, fill=False, show_dots=False)
    chart.htmlPrint()
    
    # HS06 running at all sites

    chart = VacMonStackedLine(timeSpan, timeEnd, timeBuckets)
    chart.title = 'Running HS06'

    for j in t['aggregations']['site_names']['buckets']:
      chart.add( { 'title': j['key'], 'xlink': { 'href': '/%s/%s/' % (sizeTimeRangeVO, j['key']) } },
                      siteRunningHS06Lists[j['key']],
                      fill=True, 
                      show_dots=False)

    chart.add('Max HS06', maxHS06Values, fill=False, show_dots=False)
    chart.htmlPrint()
    
  except Exception as e:
    print str(e)
    
  htmlFooter()
  
#
# PROGRAM MAIN
#

timeBuckets = 20

vacmonVersion = open('/var/www/vacmon/VERSION','r').readline().split('=',1)[1].strip()
requestURI    = os.environ['REQUEST_URI']

if '..' in requestURI or string.translate(requestURI, None, '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-./:') != '':
  # Redirect to main page if unacceptable characters in URI
  print 'Status: 302 Found 0'
  print 'Location: http://vacmon.gridpp.ac.uk/260:15180/'
  print
  sys.exit(0)

sizeTimeRangeVO, siteName, spaceName, factoryName = (requestURI + '////').split('/')[1:5]

# Static pages: main page and documentation

if not sizeTimeRangeVO:
  htmlHeader('VacMon')

  try:
    print open('/var/www/vacmon/index.html', 'r').read()
  except:
    pass  

  htmlFooter()
  sys.exit(0)

# Parse size, time range, VO
splitSizeTimeRangeVO = (sizeTimeRangeVO + ':::').split(':')

reload = False

try:
  imageSize = int(splitSizeTimeRangeVO[0], 16)
except:
  reload = True
  imageSize = 600

try:
  timeSpan = int(splitSizeTimeRangeVO[1], 16)
  
  if timeSpan % timeBuckets != 0:
    # Must be divisible by timeBuckets!      
    timeSpan = (timeSpan / timeBuckets) * timeBuckets
    reload = True
except:
  # Must be divisible by timeBuckets!
  timeSpan = (86400 / timeBuckets) * timeBuckets
  reload = True
  
if splitSizeTimeRangeVO[2] == '':
  timeEnd = int(time.time())
else:
  try:
    timeEnd = int(splitSizeTimeRangeVO[2], 16)
  except:
    timeEnd = ''
    reload = True

voName = splitSizeTimeRangeVO[3]

if reload:
  print 'Status: 302 Found'
  print ('Location: http://vacmon.gridpp.ac.uk/%x:%x:%s:%s/' % (imageSize, timeSpan, str(timeEnd), voName)) + \
         ((siteName    + '/') if siteName    else '') + \
         ((spaceName   + '/') if spaceName   else '') + \
         ((factoryName + '/') if factoryName else '')
  print
  sys.exit(0)

# Pages with graphs

if siteName and spaceName and factoryName:
  oneFactory(timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName, spaceName, factoryName)

elif siteName and spaceName:
  oneSpace(timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName, spaceName)

elif siteName:
  oneSite(timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO, siteName)

else:
  allSites(timeSpan, timeEnd, timeBuckets, voName, sizeTimeRangeVO)

sys.exit(0)
